<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>deliverable-2-2</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h2 id="abstract-syntax-tree-ast-for-c-programming-language">Abstract
Syntax Tree (AST) for C Programming Language</h2>
<h3 id="overview-of-compilation">Overview of compilation</h3>
<p>Broadly speaking, compilation of C programs refers to producing
executable binary files containing machine code from source files. It
consists of the following procedures:</p>
<ol type="1">
<li><p>Macros in a C file are expanded, and a modified C file
(referenced as an expanded C file later) is generated. This stage is
also known as preprocessing. To be more specific, a preprocessor handles
a C source file by recursively searching header files, expanding macros
in found header files, and replacing macros in the source file with
expansion results.</p></li>
<li><p>A C compiler translate a expanded C file into an assembly file
which contains human-readable machine code and assembly directives.
Compilation in the narrow sense refers to this procedure.</p></li>
<li><p>An assembler produce an object file from an assembly file. An
object file includes binary machine code but can not executed directly
at the this stage.</p></li>
<li><p>An static linker collects multiple object files and creates an
executable binary file.</p></li>
</ol>
<p>The above processes can be well illustrated by the following image
(adapted from <em>Computer Systems: A Programmer’s Perspective 3nd
Edition</em>).</p>
<figure>
<img src="/doc/img/compilation_of_c_program.png"
alt="Compilation of C Programs" />
<figcaption aria-hidden="true">Compilation of C Programs</figcaption>
</figure>
<h3 id="handling-c-macros">Handling C Macros</h3>
<p>Different from programming languages that do not support macros (such
as Java and Python) or have macros as part of their language syntax (for
example Rust), C has loose specifications about how macros can be
defined and used. Thus, a C source file may seem to have syntactic
errors even ignoring macro definitions. For example, the following code
snippet was extracted from <a
href="https://github.com/bminor/glibc/blob/bb1d27b94a3614c7e48212a04a0b28ec66fb4c49/stdlib/strtol.c#L104-L111">stdlib/strtol.c</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>INT</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>INTERNAL <span class="op">(</span>strtol<span class="op">)</span> <span class="op">(</span><span class="dt">const</span> STRING_TYPE <span class="op">*</span>nptr<span class="op">,</span> STRING_TYPE <span class="op">**</span>endptr<span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>           <span class="dt">int</span> base<span class="op">,</span> <span class="dt">int</span> group<span class="op">)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> INTERNAL <span class="op">(</span>__strtol_l<span class="op">)</span> <span class="op">(</span>nptr<span class="op">,</span> endptr<span class="op">,</span> base<span class="op">,</span> group<span class="op">,</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                _NL_CURRENT_LOCALE<span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>libc_hidden_def <span class="op">(</span>INTERNAL <span class="op">(</span>strtol<span class="op">))</span></span></code></pre></div>
<p>According to the section <em>6.9 External definitions</em> of the <a
href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">C11
specification</a>, the first part of above the code is fundamentally a
function definition if <code>INTERNAL (strtol)</code> is considered as a
declarator. By contrast,
<code>libc_hidden_def (INTERNAL (strtol))</code> is seemingly a
syntactic error because the C language specification requires
declarations, which are top-level components of a translation unit
(essentially a C source file), to end with <code>;</code>. In fact, both
<code>libc_hidden_def</code> and <code>INTERNAL</code> are macros, and
the whole line will be expanded to a valid c declaration as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> __typeof <span class="op">(</span>__strtol_internal<span class="op">)</span> __EI___strtol_internal __asm__<span class="op">(</span>__hidden_asmname <span class="op">(</span>__strtol_internal<span class="op">));</span></span></code></pre></div>
<p>To construct ASTs, there are two approaches to issues related to use
of macros. One is to first preprocess a C file and then to parse it. For
example, we can use the proprocessors of Clang and GCC to expand a C
file to a “clean” one. Later, we could utilze third-party libraries,
such as <a href="https://pypi.org/project/clang/">Python binding of
libclang</a> or Rust crate <a
href="https://docs.rs/lang-c/latest/lang_c/">lang_c</a>, to build ASTs
from it. Nevertheless, it may be significantly inconvenient to require a
file to be preprocessed for two reasons. First, for a realistic C
project, preprocessing typically requires both system and user-defined
header files. In order to obtain accurate preprocessing results, users
have to specify search paths for header files either manually or by
providing <a
href="https://clang.llvm.org/docs/JSONCompilationDatabase.html">a
compilation database</a> which records how a C compiler compiles every
file. For the latter manner, a database is generated only after a
successful compilation of the whole project. Moreover, preprocessing can
only be done on a system that has header files of relied third-party
libraries. Therefore, it may fail to build ASTs in a clean system
because the required header files are missing. In summary, it is somehow
heavy-weight to do both preprocessing and AST construction even though C
has a relatively small set of language syntax.</p>
<p>The second approach is to model common macro uses as an extended C
syntax without requiring preprocessing. For example, we could parse
<code>libc_hidden_def (INTERNAL (strtol))</code> as a declaration (or a
less common function definition) since a top-level element of a C file
is either a function definition or a declaration. Obviously, this
approach has several downsides. As C macros can be defined and used in
an extremelly flexible manner, the set of extended C syntax could be
infinitely large. It is impossible to anticipate all the ways C
developers use macros and construct an AST for each use. Therefore, it
may fail to parse a C file to ASTs if the file is not yet preprocessed
and an unexpected macro use is encountered. Nonetheless, this approach
enables parsing a C file independently, without relying on other header
files or preprocessing.</p>
<p>To conclude, preprocessing-free ASTs construction provides a good
starting point for static analysis of realistic software projects. As a
superset of standard C syntax, the extended C syntax should work with C
files that have been preprocessed. Thus, preprocessing can be integrated
in the workflow of static code analysis to obtain semantically
legitimate C structures, which could be further transformed into
low-level representations for data-flow and control-flow analysis.</p>
<h3 id="implementation-based-on-tree-sitter">Implementation based on
tree-sitter</h3>
<p><a href="https://github.com/tree-sitter/tree-sitter">Tree-sitter</a>
is an incremental parsing system for programming tools. It offers Python
bindings for many supported languages and supports C programming
langauge. Hence, we utilize tree-sitter and <a
href="https://github.com/tree-sitter/tree-sitter-c">tree-sitter-c</a> to
construct abstract syntax tree for C. Instead of directly using tree
presentations provided by tree-sitter, we create our own AST for two
reasons. First, tree-sitter syntax trees are essentially <a
href="https://en.wikipedia.org/wiki/Parse_tree">concreate syntax
trees</a> (CSTs, also known as parse trees), which keep comments,
punctuator tokens, new lines, and etc. While it could be ideal for
online code editing to keep these syntax component, it may be annoyingly
demanding to analyze CSTs. Secondly, while manipulated programmingly,
every tree node of a tree-sitter tree is of the same type and too
vaguely plain to do analysis on as tree-sitter has support for a very
large base of programming langauges. Therefore, a more specifized and
concise tree representation is necessary. Our design of abstract syntax
tree for C is primarily inspired by tree-sitter-c and adopt some syntax
structure of <a href="https://docs.rs/lang-c/latest/lang_c/">lang_c</a>
to better reflect C standard syntax.</p>
<p>As mentioned previously, although tree-sitter-c already handle
several macro uses via extended syntax, it is still possible to see
syntax errors reported by tree-sitter as unknown irregular macro uses
could potentially exist. We provide an extendable mechanism for handling
unrecognized syntax via a plugin system. If a syntax error is detected,
registered plugins are searched for a code fixing solution. Some key
interfaces for the plugin system are as follows:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span>(frozen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CodeFix:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    byte_start: <span class="bu">int</span>  <span class="co"># inclusive</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    byte_end: <span class="bu">int</span>  <span class="co"># exclusive</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    replacement: <span class="bu">bytes</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ParsingFixerInterface(metaclass<span class="op">=</span>ABCMeta):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">@abstractmethod</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> node_type(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">@abstractmethod</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> can_fix(<span class="va">self</span>, tree: Tree, curosr: TreeCursor) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">@abstractmethod</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fix(<span class="va">self</span>, tree: Tree, cursor: TreeCursor) <span class="op">-&gt;</span> CodeFix:</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ParsingFixerRegistry:</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    _registry: Dict[<span class="bu">str</span>, List[ParsingFixerInterface]] <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">@classmethod</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> register(cls, fixer: ParsingFixerInterface) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        node_type <span class="op">=</span> fixer.node_type()</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        fixer_list <span class="op">=</span> cls._registry[node_type]</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> fixer <span class="kw">in</span> fixer_list:</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>            fixer_list.append(fixer)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    <span class="at">@classmethod</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> lookup_fixer(</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        cls,</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        tree: Tree,</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        cursor: TreeCursor,</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">-&gt;</span> Optional[ParsingFixerInterface]:</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cursor.node <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>        node_type <span class="op">=</span> cursor.node.<span class="bu">type</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> fixer <span class="kw">in</span> cls._registry[node_type]:</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> fixer.can_fix(tree, cursor):</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> fixer</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span></code></pre></div>
<p>Following is a flowchart representing the AST parsing process:</p>
<figure>
<img src="/doc/img/ast_parsing_flowchart.png"
alt="Flowchart of AST Parsing" />
<figcaption aria-hidden="true">Flowchart of AST Parsing</figcaption>
</figure>
<h4 id="known-limitations">Known limitations</h4>
</body>
</html>
