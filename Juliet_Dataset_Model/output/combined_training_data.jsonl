{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_wchar_t_console_13_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = wcslen(data);\n            /* if there is room in data, read into it from the console */\n            if (256-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgetws(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgetws() */\n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/\n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        /* Typically you would do something with the search results, but this is a test case and we can ignore them */\n        /* Free the results to avoid incidentals */\n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        /* Close the connection */\n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE90 - LDAP Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__char_fscanf_18_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_51_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * data = dataRef;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            SNPRINTF(data, 100, L\"%s\", source);\n            printWLine(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    badSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_file_vprintf_52_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    CWE134_Uncontrolled_Format_String__char_file_vprintf_52b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_02_bad()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataUninitArray[10];\n    data = dataUninitArray;\n    if(1)\n    {\n        /* POTENTIAL FLAW: Partially initialize data */\n        {\n            int i;\n            for(i=0; i<(10/2); i++)\n            {\n                data[i].intOne = i;\n                data[i].intTwo = i;\n            }\n        }\n    }\n    if(1)\n    {\n        /* POTENTIAL FLAW: Use data without initializing it */\n        {\n            int i;\n            for(i=0; i<10; i++)\n            {\n                printIntLine(data[i].intOne);\n                printIntLine(data[i].intTwo);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE457 - Use of Uninitialized Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_07_good()\n{\n    goodG2B1();\n    goodG2B2();\n    goodB2G1();\n    goodB2G2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_fgets_add_53_bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE190_Integer_Overflow__int_fgets_add_53b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_rand_postinc_45_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_53_bad()\n{\n    int64_t * data;\n    /* Initialize data */\n    data = NULL;\n    /* INCIDENTAL: CWE-467 (Use of sizeof() on a pointer type) */\n    /* FLAW: Using sizeof the pointer and not the data type in malloc() */\n    data = (int64_t *)malloc(sizeof(data));\n    if (data == NULL) {exit(-1);}\n    *data = 2147483643LL;\n    CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_53b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_09_bad()\n{\n    wchar_t * data;\n    data = NULL;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = (wchar_t *)malloc(10*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (long *)malloc(100*sizeof(long));\n    if (data == NULL) {exit(-1);}\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE416_Use_After_Free__malloc_free_struct_06_bad()\n{\n    twoIntsStruct * data;\n    /* Initialize data */\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i].intOne = 1;\n                data[i].intTwo = 2;\n            }\n        }\n        /* POTENTIAL FLAW: Free data in the source - the bad sink attempts to use data */\n        free(data);\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Use of data that may have been freed */\n        printStructLine(&data[0]);\n        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE416 - Use After Free"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__unsigned_int_rand_predec_08_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__malloc_wchar_t_memcpy_07_bad()\n{\n    wchar_t * data;\n    data = NULL;\n    if(staticFive==5)\n    {\n        {\n            wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\n            if (dataBuffer == NULL) {exit(-1);}\n            wmemset(dataBuffer, L'A', 100-1);\n            dataBuffer[100-1] = L'\\0';\n            /* FLAW: Set data pointer to before the allocated memory buffer */\n            data = dataBuffer - 8;\n        }\n    }\n    {\n        wchar_t dest[100];\n        wmemset(dest, L'C', 100-1); /* fill with 'C's */\n        dest[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */\n        memcpy(dest, data, 100*sizeof(wchar_t));\n        /* Ensure null termination */\n        dest[100-1] = L'\\0';\n        printWLine(dest);\n        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n         * returned by malloc() so can't safely call free() on it */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            size_t i;\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    structType myStruct;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires delete [] to free the memory */\n    data = new wchar_t[100];\n    myStruct.structFirst = data;\n    badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char * dataBadBuffer = (char *)malloc(sizeof(OneIntClass));\n    if (dataBadBuffer == NULL) {exit(-1);}\n    char * dataGoodBuffer = (char *)malloc(sizeof(TwoIntsClass));\n    if (dataGoodBuffer == NULL) {exit(-1);}\n    /* POTENTIAL FLAW: Initialize data to a buffer small than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n            free(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_84_bad * badObject = new CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_31_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_fscanf_postdec_65_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__struct_malloc_01_bad()\n{\n    twoIntsStruct * data;\n    data = NULL; /* Initialize data */\n    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */\n    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));\n    /* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */\n    data[0].intOne = 1;\n    data[0].intTwo = 1;\n    printStructLine(&data[0]);\n    free(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE690 - Unchecked Return Value To NULL Pointer"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__malloc_char_memmove_44_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_char_connect_socket_34_bad()\n{\n    char * data;\n    CWE90_LDAP_Injection__w32_char_connect_socket_34_unionType myUnion;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            char filter[256];\n            /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/\n            _snprintf(filter, 256-1, \"(cn=%s)\", data);\n            pLdapConnection = ldap_initA(\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sA(\n                                pLdapConnection,\n                                \"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            /* Typically you would do something with the search results, but this is a test case and we can ignore them */\n            /* Free the results to avoid incidentals */\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            /* Close the connection */\n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE90 - LDAP Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_45_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_45_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_char_static_65_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE272_Least_Privilege_Violation__w32_wchar_t_RegCreateKey_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            wchar_t * keyName = L\"TEST\\\\TestKey\";\n            HKEY hKey;\n            /* FLAW: Call RegCreateKeyW() with HKEY_LOCAL_MACHINE violating the least privilege principal */\n            if (RegCreateKeyW(\n                        HKEY_LOCAL_MACHINE,\n                        keyName,\n                        &hKey) != ERROR_SUCCESS)\n            {\n                printLine(\"Registry key could not be created\");\n            }\n            else\n            {\n                printLine(\"Registry key created successfully\");\n                RegCloseKey(hKey);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE272 - Least Privilege Violation"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_console_printf_66_bad()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = wcslen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgetws() */\n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE134_Uncontrolled_Format_String__wchar_t_console_printf_66b_badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fscanf_modulo_68_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__long_malloc_13_bad()\n{\n    long * data;\n    data = NULL; /* Initialize data */\n    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */\n    data = (long *)malloc(1*sizeof(long));\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */\n        data[0] = 5L;\n        printLongLine(data[0]);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE690 - Unchecked Return Value To NULL Pointer"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    /* Initialize data*/\n    data = NULL;\n    goto source;\nsource:\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n    if (data == NULL) {exit(-1);}\n    goto sink;\nsink:\n    /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may\n     * require a call to free() to deallocate the memory */\n    delete data;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE114_Process_Control__w32_char_file_16_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE426_Untrusted_Search_Path__wchar_t_system_02_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__fopen_44_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_68_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE506_Embedded_Malicious_Code__w32_base64_encoded_payload_14_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE484_Omitted_Break_Statement_in_Switch__basic_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            int x = (rand() % 3);\n            /* FLAW: Missing break in first case */\n            switch (x)\n            {\n            case 0:\n                printLine(\"0\");\n            case 1:\n                printLine(\"1\");\n                break;\n            case 2:\n                printLine(\"2\");\n                break;\n            default:\n                printLine(\"Invalid Number\");\n                break;\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE484 - Omitted Break Statement in Switch"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_51_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_67_bad()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_67_structType myStruct;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_34_bad()\n{\n    int * data;\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_34_unionType myUnion;\n    data = NULL;\n    /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = (int *)malloc(50*sizeof(int));\n    if (data == NULL) {exit(-1);}\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(int));\n            printIntLine(data[0]);\n            free(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badGlobal = 1; /* true */\n    CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badVaSink(data, data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires delete [] to free the memory */\n    data = new long[100];\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = wcslen(data);\n        /* if there is room in data, read into it from the console */\n        if (FILENAME_MAX-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgetws() */\n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_12_bad()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_10_good()\n{\n    goodG2B1();\n    goodG2B2();\n    goodB2G1();\n    goodB2G2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE457_Use_of_Uninitialized_Variable__struct_pointer_63_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_12_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__CWE839_rand_04_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    short data;\n    /* Initialize data */\n    data = 0;\n    badSource(data);\n    /* Assume we want to allocate a relatively small buffer */\n    if (data < 100)\n    {\n        /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,\n         * the conversion will cause malloc() to allocate a very large amount of data or fail */\n        char * dataBuffer = (char *)malloc(data);\n        if (dataBuffer == NULL) {exit(-1);}\n        /* Do something with dataBuffer */\n        memset(dataBuffer, 'A', data-1);\n        dataBuffer[data-1] = '\\0';\n        printLine(dataBuffer);\n        free(dataBuffer);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    int &dataRef = data;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        int data = dataRef;\n        {\n            char source[100];\n            char dest[100] = \"\";\n            memset(source, 'A', 100-1);\n            source[100-1] = '\\0';\n            if (data < 100)\n            {\n                /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\n                 * the sign conversion could result in a very large number */\n                strncpy(dest, source, data);\n                dest[data] = '\\0'; /* strncpy() does not always NULL terminate */\n            }\n            printLine(dest);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_51_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__unsigned_int_rand_predec_08_bad()\n{\n    unsigned int data;\n    data = 0;\n    if(staticReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Use a random value */\n        data = (unsigned int)RAND32();\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            /* POTENTIAL FLAW: Decrementing data could cause an underflow */\n            --data;\n            unsigned int result = data;\n            printUnsignedLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE114_Process_Control__w32_wchar_t_file_54_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    CWE114_Process_Control__w32_wchar_t_file_54b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE114 - Process Control"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_11_bad()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        ofstream outputFile;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_console_vfprintf_41_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_system_09_bad()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n    if (SYSTEM(data) != 0)\n    {\n        printLine(\"command execution failed!\");\n        exit(1);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_rand_divide_44_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE398_Poor_Code_Quality__empty_for_18_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__short_fscanf_multiply_54_bad()\n{\n    short data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%hd\", &data);\n    CWE190_Integer_Overflow__short_fscanf_multiply_54b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32_spawnlp_08_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    /* spawnlp - searches for the location of the command among\n     * the directories specified by the PATH environment variable */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    const CWE190_Integer_Overflow__int_listen_socket_add_81_base& baseObject = CWE190_Integer_Overflow__int_listen_socket_add_81_bad();\n    baseObject.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__listen_socket_for_loop_22_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_01_bad()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\n// safe_example.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void) {\n    /* Read a user-provided string safely into a fixed-size buffer. */\n    char name[64];\n    printf(\"Enter your name (max 63 chars): \");\n    if (fgets(name, sizeof(name), stdin) == NULL) {\n        fprintf(stderr, \"Input error\\n\");\n        return 1;\n    }\n    /* Remove trailing newline, if present */\n    name[strcspn(name, \"\\n\")] = '\\0';\n\n    /* Build a greeting using snprintf (prevents buffer overflow) */\n    char greeting[128];\n    if (snprintf(greeting, sizeof(greeting), \"Hello, %s!\", name) >= (int)sizeof(greeting)) {\n        fprintf(stderr, \"Greeting truncated\\n\");\n    }\n\n    puts(greeting);\n\n    /* Example: allocate memory for a copy of the greeting */\n    size_t len = strlen(greeting) + 1;\n    char *copy = malloc(len);\n    if (copy == NULL) {\n        perror(\"malloc\");\n        return 1;\n    }\n    /* Use memcpy/strncpy carefully (here we know sizes) */\n    memcpy(copy, greeting, len); /* safe because we allocated len bytes */\n\n    printf(\"Copied greeting: %s\\n\", copy);\n\n    /* Clean up */\n    free(copy);\n    return 0;\n}\n", "target_text": "SAFE - No vulnerability detected", "source": "user_feedback", "feedback_id": "451fbf399b9d", "feedback_type": "false_positive"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_31_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__char_fscanf_multiply_44_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_fgets_postinc_65_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__short_fscanf_postdec_21_bad()\n{\n    short data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%hd\", &data);\n    badStatic = 1; /* true */\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE546_Suspicious_Comment__BUG_13_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    data = new TwoIntsClass[10];\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Partially initialize data */\n        for(int i=0; i<(10/2); i++)\n        {\n            data[i].intOne = i;\n            data[i].intTwo = i;\n        }\n    }\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Use data without initializing it */\n        for(int i=0; i<10; i++)\n        {\n            printIntLine(data[i].intOne);\n            printIntLine(data[i].intTwo);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE457 - Use of Uninitialized Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__rand_sleep_14_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_67_bad()\n{\n    char * data;\n    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_67_structType myStruct;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    data = NULL; /* Initialize data */\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n            twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(sizeof(twoIntsStruct));\n            dataBuffer->intOne = 1;\n            dataBuffer->intTwo = 1;\n            data = dataBuffer;\n        }\n    }\n    printStructLine(data);\n    /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */\n    delete data;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    myStruct.structFirst = data;\n    badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE398_Poor_Code_Quality__semicolon_13_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_51_bad()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        char buffer[sizeof(char)];\n        char * dataBuffer = new(buffer) char;\n        *dataBuffer = 'A';\n        data = dataBuffer;\n    }\n    printHexCharLine(*data);\n    /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */\n    delete data;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_struct_declare_41_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__char_fscanf_18_bad()\n{\n    goto sink;\nsink:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        fscanf(stdin, \"%99s\\0\", data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE252 - Unchecked Return Value"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    /* Initialize data */\n    data = NULL;\n    CWE415_Double_Free__new_delete_int64_t_84_bad * badObject = new CWE415_Double_Free__new_delete_int64_t_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE415 - Double Free"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    {\n        char * dataBuffer = new char[100];\n        memset(dataBuffer, 'A', 100-1);\n        dataBuffer[100-1] = '\\0';\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    const CWE127_Buffer_Underread__new_char_loop_81_base& baseObject = CWE127_Buffer_Underread__new_char_loop_81_bad();\n    baseObject.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__fgets_malloc_22_bad()\n{\n    short data;\n    /* Initialize data */\n    data = 0;\n    CWE194_Unexpected_Sign_Extension__fgets_malloc_22_badGlobal = 1; /* true */\n    data = CWE194_Unexpected_Sign_Extension__fgets_malloc_22_badSource(data);\n    /* Assume we want to allocate a relatively small buffer */\n    if (data < 100)\n    {\n        /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,\n         * the conversion will cause malloc() to allocate a very large amount of data or fail */\n        char * dataBuffer = (char *)malloc(data);\n        if (dataBuffer == NULL) {exit(-1);}\n        /* Do something with dataBuffer */\n        memset(dataBuffer, 'A', data-1);\n        dataBuffer[data-1] = '\\0';\n        printLine(dataBuffer);\n        free(dataBuffer);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    /* Initialize data*/\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n        data = (long *)calloc(100, sizeof(long));\n        if (data == NULL) {exit(-1);}\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        /* POTENTIAL FLAW: Deallocate memory using delete [] - the source memory allocation function may\n         * require a call to free() to deallocate the memory */\n        delete [] data;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE665_Improper_Initialization__char_cat_67_bad()\n{\n    char * data;\n    CWE665_Improper_Initialization__char_cat_67_structType myStruct;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Do not initialize data */\n    ; /* empty statement needed for some flow variants */\n    myStruct.structFirst = data;\n    CWE665_Improper_Initialization__char_cat_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE665 - Improper Initialization"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE404_Improper_Resource_Shutdown__freopen_w32_close_31_bad()\n{\n    FILE * data;\n    /* Initialize data */\n    data = NULL;\n    /* POTENTIAL FLAW: Open a file - need to make sure it is closed properly in the sink */\n    data = freopen(\"BadSource_freopen.txt\",\"w+\",stdin);\n    {\n        FILE * dataCopy = data;\n        FILE * data = dataCopy;\n        if (data != NULL)\n        {\n            /* FLAW: Attempt to close the file using close() instead of fclose() */\n            _close((int)data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE404 - Improper Resource Shutdown or Release"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE457_Use_of_Uninitialized_Variable__int_array_alloca_partial_init_02_bad()\n{\n    int * data;\n    data = (int *)ALLOCA(10*sizeof(int));\n    if(1)\n    {\n        /* POTENTIAL FLAW: Partially initialize data */\n        {\n            int i;\n            for(i=0; i<(10/2); i++)\n            {\n                data[i] = i;\n            }\n        }\n    }\n    if(1)\n    {\n        /* POTENTIAL FLAW: Use data without initializing it */\n        {\n            int i;\n            for(i=0; i<10; i++)\n            {\n                printIntLine(data[i]);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE457 - Use of Uninitialized Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_struct_declare_41_bad()\n{\n    twoIntsStruct * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        twoIntsStruct dataBuffer[100];\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i].intOne = 1;\n                dataBuffer[i].intTwo = 1;\n            }\n        }\n        data = dataBuffer;\n    }\n    CWE590_Free_Memory_Not_on_Heap__free_struct_declare_41_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_17_bad()\n{\n    int i;\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_17_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_09_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Use a negative number */\n        data = -1;\n    }\n    {\n        char source[100];\n        char dest[100] = \"\";\n        memset(source, 'A', 100-1);\n        source[100-1] = '\\0';\n        if (data < 100)\n        {\n            /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\n             * the sign conversion could result in a very large number */\n            memcpy(dest, source, data);\n            dest[data] = '\\0'; /* NULL terminate */\n        }\n        printLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_64_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_environment_popen_10_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    /* Initialize data*/\n    data = NULL;\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));\n    if (data == NULL) {exit(-1);}\n    CWE762_Mismatched_Memory_Management_Routines__delete_struct_realloc_82_base* baseObject = new CWE762_Mismatched_Memory_Management_Routines__delete_struct_realloc_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_54_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_54b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE680 - Integer Overflow to Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE510_Trapdoor__hostname_based_logic_09_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_01_bad()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = (char *)malloc(10*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_fscanf_square_05_bad()\n{\n    int64_t data;\n    data = 0LL;\n    if(staticTrue)\n    {\n        /* POTENTIAL FLAW: Use a value input from the console */\n        fscanf (stdin, \"%\" SCNd64, &data);\n    }\n    if(staticTrue)\n    {\n        {\n            /* POTENTIAL FLAW: if (data*data) > LLONG_MAX, this will overflow */\n            int64_t result = data * data;\n            printLongLongLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__fgets_sleep_41_bad()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read count from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            count = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    badSink(count);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    /* Initialize data*/\n    data = NULL;\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Allocate memory with a function that requires delete to free the memory */\n        data = new int;\n    }\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Deallocate memory using free() - the source memory allocation function may\n         * require a call to delete to deallocate the memory */\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    vector<twoIntsStruct *> dataVector;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i].intOne = 1;\n                dataBuffer[i].intTwo = 1;\n            }\n        }\n        data = dataBuffer;\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    badSink(dataVector);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    {\n        int dataCopy = data;\n        int data = dataCopy;\n        {\n            int i;\n            int * buffer = new int[10];\n            /* initialize buffer */\n            for (i = 0; i < 10; i++)\n            {\n                buffer[i] = 0;\n            }\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n            delete[] buffer;\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_rand_square_44_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    /* Initialize data*/\n    data = NULL;\n    if(1)\n    {\n        /* POTENTIAL FLAW: Allocate memory with a function that requires delete to free the memory */\n        data = new TwoIntsClass;\n    }\n    if(1)\n    {\n        /* POTENTIAL FLAW: Deallocate memory using delete [] - the source memory allocation function may\n         * require a call to delete to deallocate the memory */\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE114_Process_Control__w32_char_connect_socket_09_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE114 - Process Control"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    /* Initialize data*/\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Allocate memory with a function that requires delete [] to free the memory */\n        data = new int64_t[100];\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        /* POTENTIAL FLAW: Deallocate memory using free() - the source memory allocation function may\n         * require a call to delete [] to deallocate the memory */\n        free(data);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    badSink(dataVector);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    unionType myUnion;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        char buffer[sizeof(int64_t)];\n        int64_t * dataBuffer = new(buffer) int64_t;\n        *dataBuffer = 5LL;\n        data = dataBuffer;\n    }\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        printLongLongLine(*data);\n        /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */\n        delete data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_16_bad()\n{\n    char * data;\n    data = (char *)malloc(100*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    while(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE226_Sensitive_Information_Uncleared_Before_Release__w32_char_alloca_01_bad()\n{\n    {\n        char * password = (char *)ALLOCA(100*sizeof(char));\n        size_t passwordLen = 0;\n        HANDLE hUser;\n        char * username = \"User\";\n        char * domain = \"Domain\";\n        /* Initialize password */\n        password[0] = '\\0';\n        if (fgets(password, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            password[0] = '\\0';\n        }\n        /* Remove the carriage return from the string that is inserted by fgets() */\n        passwordLen = strlen(password);\n        if (passwordLen > 0)\n        {\n            password[passwordLen-1] = '\\0';\n        }\n        /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n        if (LogonUserA(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &hUser) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(hUser);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n        /* FLAW: Release password from the stack without first clearing the buffer */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE226 - Sensitive Information Uncleared Before Release"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_connect_socket_popen_61_bad()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    data = CWE78_OS_Command_Injection__char_connect_socket_popen_61b_badSource(data);\n    {\n        FILE *pipe;\n        /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fscanf_divide_45_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_15_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_connect_socket_postinc_32_bad()\n{\n    int data;\n    int *dataPtr1 = &data;\n    int *dataPtr2 = &data;\n    /* Initialize data */\n    data = 0;\n    {\n        int data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        int data = *dataPtr2;\n        {\n            /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_22_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_10_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_65_bad()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_65b_badSink;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = (wchar_t *)malloc(10*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE114_Process_Control__w32_char_connect_socket_09_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE571_Expression_Always_True__string_equals_01_good() \n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__CWE839_fgets_12_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n        * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to access a negative index of the array\n            * This code does not check to see if the array index is negative */\n            if (data < 10)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer underwrite */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_console_printf_66_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__struct_malloc_01_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    if(globalFive==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new TwoIntsClass[50];\n    }\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE259_Hard_Coded_Password__w32_char_31_bad()\n{\n    char * password;\n    char passwordBuffer[100] = \"\";\n    password = passwordBuffer;\n    /* FLAW: Use a hardcoded password */\n    strcpy(password, PASSWORD);\n    {\n        char * passwordCopy = password;\n        char * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            char * username = \"User\";\n            char * domain = \"Domain\";\n            /* POTENTIAL FLAW: Attempt to login user with password from the source (which may be hardcoded) */\n            if (LogonUserA(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE259 - Use of Hard-coded Password"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_03_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_listen_socket_popen_07_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_13_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_51_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_08_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        size_t i;\n        int *intPointer;\n        /* POTENTIAL FLAW: if data * sizeof(int) > SIZE_MAX, overflows to a small value\n         * so that the for loop doing the initialization causes a buffer overflow */\n        intPointer = (int*)malloc(data * sizeof(int));\n        if (intPointer == NULL) {exit(-1);}\n        for (i = 0; i < (size_t)data; i++)\n        {\n            intPointer[i] = 0; /* Potentially writes beyond the boundary of intPointer */\n        }\n        printIntLine(intPointer[0]);\n        free(intPointer);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE680 - Integer Overflow to Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_printf_06_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        char buffer[sizeof(twoIntsStruct)];\n        twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;\n        dataBuffer->intOne = 1;\n        dataBuffer->intTwo = 1;\n        data = dataBuffer;\n    }\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_31_bad()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = (char *)malloc(50*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            size_t i;\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            free(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE546_Suspicious_Comment__BUG_03_bad()\n{\n    if(5==5)\n    {\n        /* FLAW: The following comment has the letters 'BUG' in it*/\n        /* BUG: This comment has the letters 'BUG' in it, which is certainly\n         * suspicious, because it could indicate this code has a BUG in it.\n         */\n        printLine(\"Hello\");\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE546 - Suspicious Comment"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_32_bad()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            /* spawnvp - searches for the location of the command among\n             * the directories specified by the PATH environment variable */\n            /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n            _spawnvp(_P_WAIT, COMMAND_INT, args);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE284_Improper_Access_Control__w32_wchar_t_SHRegCreateUSKey_11_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_04_bad()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__malloc_wchar_t_loop_42_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    /* Initialize data */\n    data = NULL;\n    data = new int;\n    /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */\n    delete data;\n    /* POTENTIAL FLAW: Possibly deleting memory twice */\n    delete data;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE415 - Double Free"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        static int dataBuffer[100];\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i] = 5;\n            }\n        }\n        data = dataBuffer;\n    }\n    const CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_81_base& baseObject = CWE590_Free_Memory_Not_on_Heap__delete_array_int_static_81_bad();\n    baseObject.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_03_good()\n{\n    goodG2B1();\n    goodG2B2();\n    goodB2G1();\n    goodB2G2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_42_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    data = badSource(data);\n    /* wspawnlp - searches for the location of the command among\n     * the directories specified by the PATH environment variable */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_fgets_predec_10_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_10_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory on the heap */\n    data = new twoIntsStruct;\n    /* Initialize and make use of data */\n    data->intOne = 0;\n    data->intTwo = 0;\n    printStructLine(data);\n    badStatic = 1; /* true */\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE617_Reachable_Assertion__zero_11_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    if(staticTrue)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_51_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_08_bad()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_rand_postinc_31_bad()\n{\n    int64_t data;\n    data = 0LL;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (int64_t)RAND64();\n    {\n        int64_t dataCopy = data;\n        int64_t data = dataCopy;\n        {\n            /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n            data++;\n            int64_t result = data;\n            printLongLongLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__char_alloca_cpy_17_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_max_postinc_13_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        int64_t dataBuffer[100];\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i] = 5LL;\n            }\n        }\n        data = dataBuffer;\n    }\n    badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    /* Initialize data */\n    data = NULL;\n    if(GLOBAL_CONST_TRUE)\n    {\n        data = new twoIntsStruct;\n        /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */\n        delete data;\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Possibly deleting memory twice */\n        delete data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE415 - Double Free"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE284_Improper_Access_Control__w32_wchar_t_SHRegCreateUSKey_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            wchar_t * keyName = L\"TEST\\\\TestKey\";\n            HUSKEY hKey = HKEY_CURRENT_USER;\n            /* FLAW: Call SHRegCreateUSKeyW() with KEY_ALL_ACCESS as the 2nd parameter */\n            if (SHRegCreateUSKeyW(\n                        keyName,\n                        KEY_ALL_ACCESS,\n                        NULL,\n                        &hKey,\n                        SHREGSET_HKCU) != ERROR_SUCCESS)\n            {\n                printLine(\"Registry key could not be created\");\n            }\n            else\n            {\n                printLine(\"Registry key created successfully\");\n                SHRegCloseUSKey(hKey);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE284 - Improper Access Control"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    structType myStruct;\n    /* Initialize data*/\n    data = NULL;\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    myStruct.structFirst = data;\n    badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_31_bad()\n{\n    wchar_t * password;\n    /* Initialize Data */\n    password = L\"\";\n    password = (wchar_t *)malloc(100*sizeof(wchar_t));\n    if (password == NULL)\n    {\n        printLine(\"Memory could not be allocated\");\n        exit(1);\n    }\n    /* FLAW: Do not lock the memory */\n    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */\n    wcscpy(password, L\"Password1234!\");\n    {\n        wchar_t * passwordCopy = password;\n        wchar_t * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n            /* POTENTIAL FLAW: Sensitive data possibly improperly locked */\n            free(password);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE591 - Sensitive Data Storage in Improperly Locked Memory"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_02_bad()\n{\n    size_t data;\n    /* Initialize data */\n    data = 0;\n    if(1)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to unsigned int */\n                data = strtoul(inputBuffer, NULL, 0);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(1)\n    {\n        {\n            wchar_t * myString;\n            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough\n             * for the wcscpy() function to not cause a buffer overflow */\n            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */\n            if (data > wcslen(HELLO_STRING))\n            {\n                myString = (wchar_t *)malloc(data*sizeof(wchar_t));\n                if (myString == NULL) {exit(-1);}\n                /* Copy a small string into myString */\n                wcscpy(myString, HELLO_STRING);\n                printWLine(myString);\n                free(myString);\n            }\n            else\n            {\n                printLine(\"Input is less than the length of the source string\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE789 - Uncontrolled Memory Allocation"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__malloc_char_cpy_63_bad()\n{\n    char * data;\n    data = NULL;\n    {\n        char * dataBuffer = (char *)malloc(100*sizeof(char));\n        if (dataBuffer == NULL) {exit(-1);}\n        memset(dataBuffer, 'A', 100-1);\n        dataBuffer[100-1] = '\\0';\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    CWE127_Buffer_Underread__malloc_char_cpy_63b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    /* Initialize data*/\n    data = NULL;\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Allocate memory with a function that requires delete to free the memory */\n        data = new int64_t;\n    }\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Deallocate memory using free() - the source memory allocation function may\n         * require a call to delete to deallocate the memory */\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_10_bad()\n{\n    size_t data;\n    /* Initialize data */\n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to unsigned int */\n                data = strtoul(inputBuffer, NULL, 0);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            char * myString;\n            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough\n             * for the strcpy() function to not cause a buffer overflow */\n            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */\n            if (data > strlen(HELLO_STRING))\n            {\n                myString = (char *)malloc(data*sizeof(char));\n                if (myString == NULL) {exit(-1);}\n                /* Copy a small string into myString */\n                strcpy(myString, HELLO_STRING);\n                printLine(myString);\n                free(myString);\n            }\n            else\n            {\n                printLine(\"Input is less than the length of the source string\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE789 - Uncontrolled Memory Allocation"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_31_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_connect_socket_postinc_32_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__CWE839_negative_34_bad()\n{\n    int data;\n    CWE124_Buffer_Underwrite__CWE839_negative_34_unionType myUnion;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = -5;\n    myUnion.unionFirst = data;\n    {\n        int data = myUnion.unionSecond;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to access a negative index of the array\n            * This code does not check to see if the array index is negative */\n            if (data < 10)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_32_bad()\n{\n    int data;\n    int *dataPtr1 = &data;\n    int *dataPtr2 = &data;\n    /* Initialize data */\n    data = -1;\n    {\n        int data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        int data = *dataPtr2;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66_bad()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66b_badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_32_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_char_alloca_65_bad()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE590_Free_Memory_Not_on_Heap__free_char_alloca_65b_badSink;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n        memset(dataBuffer, 'A', 100-1); /* fill with 'A's */\n        dataBuffer[100-1] = '\\0'; /* null terminate */\n        data = dataBuffer;\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fgets_divide_04_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE416_Use_After_Free__malloc_free_int_09_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        ifstream inputFile;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read count from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            count = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE400_Resource_Exhaustion__fgets_fwrite_82_base* baseObject = new CWE400_Resource_Exhaustion__fgets_fwrite_82_bad;\n    baseObject->action(count);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = badSink;\n    /* Initialize data*/\n    data = NULL;\n    {\n        char myString[] = \"myString\";\n        /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n        data = strdup(myString);\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE223_Omission_of_Security_Relevant_Information__w32_15_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_16_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    while(1)\n    {\n        /* FLAW: Use a negative number */\n        data = -1;\n        break;\n    }\n    /* Assume we want to allocate a relatively small buffer */\n    if (data < 100)\n    {\n        /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,\n         * the conversion will cause malloc() to allocate a very large amount of data or fail */\n        char * dataBuffer = (char *)malloc(data);\n        if (dataBuffer == NULL) {exit(-1);}\n        /* Do something with dataBuffer */\n        memset(dataBuffer, 'A', data-1);\n        dataBuffer[data-1] = '\\0';\n        printLine(dataBuffer);\n        free(dataBuffer);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_17_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_51_bad()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_long_static_01_bad()\n{\n    long * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        static long dataBuffer[100];\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i] = 5L;\n            }\n        }\n        data = dataBuffer;\n    }\n    printLongLine(data[0]);\n    /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */\n    free(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fgets_divide_04_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Possibly divide by zero */\n        printIntLine(100 / data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE366_Race_Condition_Within_Thread__int_byref_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            stdThread threadA = NULL;\n            stdThread threadB = NULL;\n            int valBadSink;\n            valBadSink = 0;\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))\n            {\n                threadA = NULL;\n            }\n            if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))\n            {\n                threadB = NULL;\n            }\n            if (threadA && stdThreadJoin(threadA))\n            {\n                stdThreadDestroy(threadA);\n            }\n            if (threadB && stdThreadJoin(threadB))\n            {\n                stdThreadDestroy(threadB);\n            }\n            printIntLine(valBadSink);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE366 - Race Condition Within a Thread"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__fscanf_strncpy_64_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_fscanf_square_05_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_31_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_16_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_83_bad badObject(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_42_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_17_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = (char *)malloc(50*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    data[0] = '\\0'; /* null terminate */\n    const CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_81_base& baseObject = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_81_bad();\n    baseObject.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_loop_32_bad()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    data = (char *)malloc(100*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char dest[50] = \"\";\n            size_t i, dataLen;\n            dataLen = strlen(data);\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            for (i = 0; i < dataLen; i++)\n            {\n                dest[i] = data[i];\n            }\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            free(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_console_execl_42_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    data = badSource(data);\n    /* execl - specify the path where the command is located */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        ifstream inputFile;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE284_Improper_Access_Control__w32_char_CreateFile_02_bad()\n{\n    if(1)\n    {\n        {\n            HANDLE hFile;\n            char * fileName = \"C:\\\\temp\\\\file.txt\";\n            /* FLAW: Call CreateFileA() with FILE_ALL_ACCESS as the 2nd parameter */\n            hFile = CreateFileA(\n                        fileName,\n                        FILE_ALL_ACCESS,\n                        FILE_SHARE_READ,\n                        NULL,\n                        CREATE_NEW,\n                        FILE_ATTRIBUTE_NORMAL,\n                        NULL);\n            if (hFile == INVALID_HANDLE_VALUE)\n            {\n                printLine(\"File could not be created\");\n            }\n            else\n            {\n                printLine(\"File created successfully\");\n                CloseHandle(hFile);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE284 - Improper Access Control"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_03_bad()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(5==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    unionType myUnion;\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory on the heap */\n    data = new int64_t;\n    /* Initialize and make use of data */\n    *data = 5LL;\n    printLongLongLine(*data);\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        /* POTENTIAL FLAW: No deallocation */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory on the heap */\n    data = (int64_t *)realloc(data, 100*sizeof(int64_t));\n    if (data == NULL) {exit(-1);}\n    /* Initialize and make use of data */\n    data[0] = 5LL;\n    printLongLongLine(data[0]);\n    const CWE401_Memory_Leak__int64_t_realloc_81_base& baseObject = CWE401_Memory_Leak__int64_t_realloc_81_bad();\n    baseObject.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__char_alloca_ncpy_11_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE15_External_Control_of_System_or_Configuration_Setting__w32_54_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_09_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE506_Embedded_Malicious_Code__w32_base64_encoded_payload_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* FLAW: encoded \"calc.exe\" */\n            char * encodedPayload = \"Y2FsYy5leGU=\";\n            BYTE * decodedPayload = NULL;\n            DWORD requiredLength;\n            do\n            {\n                /* Calculate the number of bytes needed to decode */\n                if (!CryptStringToBinaryA(encodedPayload,\n                                          strlen(encodedPayload),\n                                          CRYPT_STRING_BASE64,\n                                          NULL,\n                                          &requiredLength,\n                                          NULL,\n                                          NULL))\n                {\n                    break;\n                }\n                /* Allocate memory for the decoded message */\n                decodedPayload = (BYTE*) malloc(requiredLength + 1);\n                if (decodedPayload == NULL)\n                {\n                    break;\n                }\n                /* Decode */\n                if (!CryptStringToBinaryA(encodedPayload,\n                                          strlen(encodedPayload),\n                                          CRYPT_STRING_BASE64,\n                                          decodedPayload,\n                                          &requiredLength,\n                                          NULL,\n                                          NULL))\n                {\n                    break;\n                }\n                /* NULL terminate */\n                decodedPayload[requiredLength] = '\\0';\n                if (system((char*)decodedPayload) <= 0)\n                {\n                    printLine(\"command execution failed!\");\n                    exit(1);\n                }\n            }\n            while (0);\n            free(decodedPayload);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE506 - Embedded Malicious Code"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_char_declare_07_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__char_sscanf_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        /* By initializing dataBuffer, we ensure this will not be the\n         * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n        char dataBuffer[100] = \"\";\n        char * data = dataBuffer;\n        /* FLAW: Do not check the return value */\n        sscanf(SRC, \"%99s\\0\", data);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE252 - Unchecked Return Value"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE511_Logic_Time_Bomb__rand_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        srand((unsigned)time(NULL));\n        /* FLAW: If a certain number, delete a file */\n        if (rand() == NUM_CHECK)\n        {\n            UNLINK(\"important_file.txt\");\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE511 - Logic Time Bomb"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_15_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[250] = L\"PATH=\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */\n    PUTENV(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE427 - Uncontrolled Search Path Element"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__wchar_t_realloc_63_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_03_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_int_static_64_bad()\n{\n    int * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        static int dataBuffer[100];\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i] = 5;\n            }\n        }\n        data = dataBuffer;\n    }\n    CWE590_Free_Memory_Not_on_Heap__free_int_static_64b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_fscanf_square_68_bad()\n{\n    int64_t data;\n    data = 0LL;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%\" SCNd64, &data);\n    CWE190_Integer_Overflow__int64_t_fscanf_square_68_badData = data;\n    CWE190_Integer_Overflow__int64_t_fscanf_square_68b_badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    size_t data;\n    map<int, size_t> dataMap;\n    /* Initialize data */\n    data = 0;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to unsigned int */\n            data = strtoul(inputBuffer, NULL, 0);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE789 - Uncontrolled Memory Allocation"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char * dataBuffer = new char[100];\n            memset(dataBuffer, 'A', 100-1);\n            dataBuffer[100-1] = '\\0';\n            /* FLAW: Set data pointer to before the allocated memory buffer */\n            data = dataBuffer - 8;\n        }\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        memmove(data, source, 100*sizeof(char));\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n         * returned by new [] so can't safely call delete [] on it */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__int_malloc_42_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    CWE36_Absolute_Path_Traversal__wchar_t_file_ifstream_83_bad badObject(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__negative_malloc_09_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE404_Improper_Resource_Shutdown__freopen_w32_close_31_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE563_Unused_Variable__unused_uninit_variable_long_21_good()\n{\n    goodB2G1();\n    goodB2G2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    unsigned int data;\n    list<unsigned int> dataList;\n    data = 0;\n    /* POTENTIAL FLAW: Use the maximum size of the data type */\n    data = UINT_MAX;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    badSink(dataList);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_rand_multiply_64_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__char_alloca_ncpy_45_bad()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    /* FLAW: Set data pointer to before the allocated memory buffer */\n    data = dataBuffer - 8;\n    CWE127_Buffer_Underread__char_alloca_ncpy_45_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__strdup_char_34_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[250] = L\"PATH=\";\n    data = dataBuffer;\n    badSource(data);\n    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */\n    PUTENV(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE427 - Uncontrolled Search Path Element"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_22_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_file_system_65_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_fscanf_add_01_bad()\n{\n    unsigned int data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%u\", &data);\n    {\n        /* POTENTIAL FLAW: Adding 1 to data could cause an overflow */\n        unsigned int result = data + 1;\n        printUnsignedLine(result);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_console_vfprintf_41_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_10_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__CWE839_negative_34_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    const CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_81_bad();\n    baseObject.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    /* Initialize data*/\n    data = NULL;\n    if(globalTrue)\n    {\n        /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n        data = (wchar_t *)calloc(100, sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n    }\n    if(globalTrue)\n    {\n        /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may\n         * require a call to free() to deallocate the memory */\n        delete data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE680 - Integer Overflow to Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_console_fprintf_64_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    CWE134_Uncontrolled_Format_String__char_console_fprintf_64b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_51_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE478_Missing_Default_Case_in_Switch__basic_07_bad()\n{\n    if(staticFive==5)\n    {\n        {\n            const char *charString = \"shouldn\\'t see this value\";\n            int x;\n            x = (rand() % 3);\n            switch (x)\n            {\n            case 0:\n                charString = \"0\";\n                break;\n            case 1:\n                charString = \"1\";\n                break;\n                /* FLAW: x could be 2, and there is no 'default' case for that */\n            }\n            printLine(charString);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE478 - Missing Default Case in Switch"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE197_Numeric_Truncation_Error__int_rand_to_short_53_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_32_bad()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        badVaSink(data, data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE510_Trapdoor__hostname_based_logic_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            struct sockaddr_in service, acceptService;\n            int acceptServiceLen = sizeof(acceptService);\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char hostname[NI_MAXHOST];\n            char servInfo[NI_MAXSERV];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(20000);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, 5) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (getsockname(acceptSocket, (struct sockaddr *)&acceptService, &acceptServiceLen) == -1)\n                {\n                    break;\n                }\n                if (getnameinfo((struct sockaddr *)&acceptService,\n                                sizeof(struct sockaddr),\n                                hostname,\n                                NI_MAXHOST, servInfo, NI_MAXSERV, NI_NUMERICSERV) != 0)\n                {\n                    break;\n                }\n                /* FLAW: host-based logic */\n                if (strcmp(\"admin.google.com\", hostname) == 0)\n                {\n                    if (send(acceptSocket, ADMIN_MESSAGE, strlen(ADMIN_MESSAGE), 0) ==  SOCKET_ERROR)\n                    {\n                        /* Do not alert user to trapdoor, no action */\n                        break;\n                    }\n                }\n                else\n                {\n                    if (send(acceptSocket, DEFAULT_MESSAGE, strlen(DEFAULT_MESSAGE), 0) == SOCKET_ERROR)\n                    {\n                        printLine(\"Send failed!\");\n                    }\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE510 - Trapdoor"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_09_bad()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_09_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_67_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE476_NULL_Pointer_Dereference__int_68_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_fgets_predec_10_bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    if(globalTrue)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            /* POTENTIAL FLAW: Decrementing data could cause an underflow */\n            --data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_22_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_22_badGlobal = 1; /* true */\n    data = CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_22_badSource(data);\n    /* spawnl - specify the path where the command is located */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__char_alloca_ncpy_45_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Allocate memory on the heap */\n        data = new int;\n        /* Initialize and make use of data */\n        *data = 5;\n        printIntLine(*data);\n    }\n    if(staticReturnsTrue())\n    {\n        /* POTENTIAL FLAW: No deallocation */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__fscanf_strncpy_01_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__char_rand_add_11_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_char_environment_51_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_file_vprintf_42_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE129_large_04_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_63_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_83_bad badObject(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__listen_socket_sleep_65_bad()\n{\n    int count;\n    /* define a function pointer */\n    void (*funcPtr) (int) = CWE400_Resource_Exhaustion__listen_socket_sleep_65b_badSink;\n    /* Initialize count */\n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read count using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* use the function pointer */\n    funcPtr(count);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__short_fscanf_predec_17_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__int_malloc_42_bad()\n{\n    int * data;\n    data = NULL; /* Initialize data */\n    data = badSource(data);\n    /* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */\n    data[0] = 5;\n    printIntLine(data[0]);\n    free(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE690 - Unchecked Return Value To NULL Pointer"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    unionType myUnion;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_11_bad()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__char_malloc_32_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_02_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67_bad()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67_structType myStruct;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_file_vfprintf_01_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    badVaSink(data, data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__rand_malloc_68_bad()\n{\n    short data;\n    /* Initialize data */\n    data = 0;\n    /* FLAW: Use a random value that could be less than 0 */\n    data = (short)RAND32();\n    CWE194_Unexpected_Sign_Extension__rand_malloc_68_badData = data;\n    CWE194_Unexpected_Sign_Extension__rand_malloc_68b_badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fgets_divide_11_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrue())\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(globalReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Possibly divide by zero */\n        printIntLine(100 / data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE457_Use_of_Uninitialized_Variable__double_array_declare_partial_init_14_bad()\n{\n    double * data;\n    double dataUninitArray[10];\n    data = dataUninitArray;\n    if(globalFive==5)\n    {\n        /* POTENTIAL FLAW: Partially initialize data */\n        {\n            int i;\n            for(i=0; i<(10/2); i++)\n            {\n                data[i] = (double)i;\n            }\n        }\n    }\n    if(globalFive==5)\n    {\n        /* POTENTIAL FLAW: Use data without initializing it */\n        {\n            int i;\n            for(i=0; i<10; i++)\n            {\n                printDoubleLine(data[i]);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE457 - Use of Uninitialized Variable"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    CWE78_OS_Command_Injection__wchar_t_environment_system_84_bad * badObject = new CWE78_OS_Command_Injection__wchar_t_environment_system_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_rand_postinc_31_bad()\n{\n    unsigned int data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    {\n        unsigned int dataCopy = data;\n        unsigned int data = dataCopy;\n        {\n            /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n            data++;\n            unsigned int result = data;\n            printUnsignedLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    {\n        char * data = dataRef;\n        {\n            int fileDesc;\n            /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n            fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE427_Uncontrolled_Search_Path_Element__char_file_51_bad()\n{\n    char * data;\n    char dataBuffer[250] = \"PATH=\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (250-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    CWE427_Uncontrolled_Search_Path_Element__char_file_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE427 - Uncontrolled Search Path Element"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    short data;\n    /* Initialize data */\n    data = 0;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        int tempInt;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* FLAW: Use a value input from the network */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to short - ensure int to short conversion will be successful and if\n             * not ensure that data will be negative */\n            tempInt = atoi(inputBuffer);\n            if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)\n            {\n                data = -1;\n            }\n            else\n            {\n                data = tempInt;\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE194_Unexpected_Sign_Extension__connect_socket_malloc_82_base* baseObject = new CWE194_Unexpected_Sign_Extension__connect_socket_malloc_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_07_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_17_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE325_Missing_Required_Cryptographic_Step__w32_CryptEncrypt_03_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__char_alloca_ncpy_11_bad()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    {\n        char dest[100];\n        memset(dest, 'C', 100-1); /* fill with 'C's */\n        dest[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */\n        strncpy(dest, data, strlen(dest));\n        /* Ensure null termination */\n        dest[100-1] = '\\0';\n        printLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE114_Process_Control__w32_wchar_t_connect_socket_44_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__connect_socket_for_loop_07_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_17_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    data = new int[10];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Partially initialize data */\n        {\n            int i;\n            for(i=0; i<(10/2); i++)\n            {\n                data[i] = i;\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Use data without initializing it */\n        {\n            int i;\n            for(i=0; i<10; i++)\n            {\n                printIntLine(data[i]);\n            }\n        }\n        /* deallocate the memory */\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE457 - Use of Uninitialized Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE426_Untrusted_Search_Path__char_system_18_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__malloc_wchar_t_memmove_45_bad()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Use a small buffer */\n    data = (wchar_t *)malloc(50*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    wmemset(data, L'A', 50-1); /* fill with 'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE126_Buffer_Overread__malloc_wchar_t_memmove_45_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Over-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE197_Numeric_Truncation_Error__int_rand_to_short_53_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE197_Numeric_Truncation_Error__int_rand_to_short_53b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE197 - Numeric Truncation Error"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = (wchar_t *)malloc(100*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    data[0] = L'\\0';\n    CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_84_bad * badObject = new CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE761 - Free Pointer not at Start of Buffer"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_rand_square_44_bad()\n{\n    int64_t data;\n    /* define a function pointer */\n    void (*funcPtr) (int64_t) = badSink;\n    data = 0LL;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (int64_t)RAND64();\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__short_fscanf_postdec_21_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_18_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    goto source;\nsource:\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    {\n        char source[100];\n        char dest[100] = \"\";\n        memset(source, 'A', 100-1);\n        source[100-1] = '\\0';\n        if (data < 100)\n        {\n            /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\n             * the sign conversion could result in a very large number */\n            strncpy(dest, source, data);\n            dest[data] = '\\0'; /* strncpy() does not always NULL terminate */\n        }\n        printLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE457_Use_of_Uninitialized_Variable__struct_13_bad()\n{\n    twoIntsStruct data;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Don't initialize data */\n        ; /* empty statement needed for some flow variants */\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Use data without initializing it */\n        printIntLine(data.intOne);\n        printIntLine(data.intTwo);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE457 - Use of Uninitialized Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_console_63_bad()\n{\n    wchar_t * data;\n    data = (wchar_t *)malloc(100*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    data[0] = L'\\0';\n    {\n        /* Read input from the console */\n        size_t dataLen = wcslen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgetws() */\n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_console_63b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE761 - Free Pointer not at Start of Buffer"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__float_connect_socket_34_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_fscanf_postdec_65_bad()\n{\n    int data;\n    /* define a function pointer */\n    void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_postdec_65b_badSink;\n    /* Initialize data */\n    data = 0;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_67_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_fgets_preinc_31_bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    {\n        int dataCopy = data;\n        int data = dataCopy;\n        {\n            /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_char_static_65_bad()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE590_Free_Memory_Not_on_Heap__free_char_static_65b_badSink;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        static char dataBuffer[100];\n        memset(dataBuffer, 'A', 100-1); /* fill with 'A's */\n        dataBuffer[100-1] = '\\0'; /* null terminate */\n        data = dataBuffer;\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_char_declare_66_bad()\n{\n    char * data;\n    char * dataArray[5];\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        char dataBuffer[100];\n        memset(dataBuffer, 'A', 100-1); /* fill with 'A's */\n        dataBuffer[100-1] = '\\0'; /* null terminate */\n        data = dataBuffer;\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE590_Free_Memory_Not_on_Heap__free_char_declare_66b_badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_08_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__float_fgets_51_bad()\n{\n    float data;\n    /* Initialize data */\n    data = 0.0F;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        /* POTENTIAL FLAW: Use a value input from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to float */\n            data = (float)atof(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE369_Divide_by_Zero__float_fgets_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_05_bad()\n{\n    char * data;\n    data = NULL;\n    if(staticTrue)\n    {\n        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = (char *)malloc(50*sizeof(char));\n        if (data == NULL) {exit(-1);}\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strcpy(data, source);\n        printLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    if(5==5)\n    {\n        {\n            char * dataBuffer = new char[100];\n            memset(dataBuffer, 'A', 100-1);\n            dataBuffer[100-1] = '\\0';\n            /* FLAW: Set data pointer to before the allocated memory buffer */\n            data = dataBuffer - 8;\n        }\n    }\n    {\n        char dest[100];\n        memset(dest, 'C', 100-1); /* fill with 'C's */\n        dest[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */\n        memcpy(dest, data, 100*sizeof(char));\n        /* Ensure null termination */\n        dest[100-1] = '\\0';\n        printLine(dest);\n        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n         * returned by new [] so can't safely call delete [] on it */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_09_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_console_snprintf_45_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = wcslen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgetws() */\n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    CWE134_Uncontrolled_Format_String__wchar_t_console_snprintf_45_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE563_Unused_Variable__unused_value_int64_t_08_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__strdup_wchar_t_08_bad()\n{\n    wchar_t * data;\n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        {\n            wchar_t myString[] = L\"myString\";\n            /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */\n            data = wcsdup(myString);\n            /* Use data */\n            printWLine(data);\n        }\n    }\n    if(staticReturnsTrue())\n    {\n        /* POTENTIAL FLAW: No deallocation of memory */\n        /* no deallocation */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE367_TOC_TOU__stat_15_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    data = NULL;\n    /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = (wchar_t *)malloc(50*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__short_fscanf_multiply_68_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32_spawnlp_08_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE226_Sensitive_Information_Uncleared_Before_Release__w32_char_alloca_01_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_02_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    badSink(dataList);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__connect_socket_for_loop_52_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__int64_t_malloc_13_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE398_Poor_Code_Quality__semicolon_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: the statement has no effect */\n        ;\n        printLine(\"Hello from bad()\");\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE398 - Poor Code Quality"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__strdup_wchar_t_08_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE675_Duplicate_Operations_on_Resource__open_52_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE534_Info_Exposure_Debug_Log__w32_wchar_t_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            wchar_t password[100] = L\"\";\n            size_t passwordLen = 0;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            FILE * pFile = fopen(\"debug.txt\", \"a+\");\n            if (fgetws(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                password[0] = L'\\0';\n            }\n            /* Remove the carriage return from the string that is inserted by fgetws() */\n            passwordLen = wcslen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = L'\\0';\n            }\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n            /* FLAW: Write sensitive data to the log */\n            fwprintf(pFile, L\"User attempted access with password: %s\\n\", password);\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE534 - Information Exposure Through Debug Log Files"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_fgets_preinc_31_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE665_Improper_Initialization__char_cat_67_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    /* Initialize data*/\n    data = NULL;\n    CWE762_Mismatched_Memory_Management_Routines__delete_int64_t_calloc_84_bad * badObject = new CWE762_Mismatched_Memory_Management_Routines__delete_int64_t_calloc_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_console_snprintf_45_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__strdup_char_34_bad()\n{\n    char * data;\n    CWE401_Memory_Leak__strdup_char_34_unionType myUnion;\n    data = NULL;\n    {\n        char myString[] = \"myString\";\n        /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */\n        data = strdup(myString);\n        /* Use data */\n        printLine(data);\n    }\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        /* POTENTIAL FLAW: No deallocation of memory */\n        /* no deallocation */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_02_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(1)\n    {\n        /* FLAW: Use a negative number */\n        data = -1;\n    }\n    {\n        char source[100];\n        char dest[100] = \"\";\n        memset(source, 'A', 100-1);\n        source[100-1] = '\\0';\n        if (data < 100)\n        {\n            /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\n             * the sign conversion could result in a very large number */\n            strncpy(dest, source, data);\n            dest[data] = '\\0'; /* strncpy() does not always NULL terminate */\n        }\n        printLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__struct_realloc_22_good()\n{\n    goodB2G1();\n    goodB2G2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    list<int>  data;\n    CWE672_Operation_on_Resource_After_Expiration_or_Release__list_int_83_bad badObject(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE672 - Operation on Resource After Expiration or Release"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE546_Suspicious_Comment__BUG_13_bad()\n{\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: The following comment has the letters 'BUG' in it*/\n        /* BUG: This comment has the letters 'BUG' in it, which is certainly\n         * suspicious, because it could indicate this code has a BUG in it.\n         */\n        printLine(\"Hello\");\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE546 - Suspicious Comment"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_connect_socket_popen_61_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        /* Restore NUL terminator if fgetws fails */\n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        pFile = FOPEN(data, L\"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_console_w32_vsnprintf_45_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE114_Process_Control__w32_wchar_t_connect_socket_44_bad()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = badSink;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE114 - Process Control"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_31_bad()\n{\n    wchar_t * data;\n    data = (wchar_t *)malloc(100*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            wcsncpy(dest, data, wcslen(data));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n            free(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    {\n        char * dataBuffer = new char[100];\n        memset(dataBuffer, 'A', 100-1);\n        dataBuffer[100-1] = '\\0';\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n            memcpy(data, source, 100*sizeof(char));\n            /* Ensure the destination buffer is null terminated */\n            data[100-1] = '\\0';\n            printLine(data);\n            /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n             * returned by new [] so can't safely call delete [] on it */\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_17_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__malloc_char_memcpy_53_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    /* Initialize data*/\n    data = NULL;\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (char *)realloc(data, 100*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    const CWE762_Mismatched_Memory_Management_Routines__delete_array_char_realloc_81_base& o = CWE762_Mismatched_Memory_Management_Routines__delete_array_char_realloc_81_bad();\n    o.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_wchar_t_declare_05_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE426_Untrusted_Search_Path__wchar_t_system_02_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        /* FLAW: the full path is not specified */\n        wcscpy(data, BAD_OS_COMMAND);\n    }\n    /* POTENTIAL FLAW: Executing the _wsystem() function without specifying the full path to the executable\n     * can allow an attacker to run their own program */\n    if (SYSTEM(data) <= 0)\n    {\n        printLine(\"command execution failed!\");\n        exit(1);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE426 - Untrusted Search Path"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_console_execl_42_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE259_Hard_Coded_Password__w32_char_31_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    data = NULL;\n    badStatic = 1; /* true */\n    data = badSource(data);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n    ;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_21_bad()\n{\n    char * data;\n    data = NULL;\n    badStatic = 1; /* true */\n    data = badSource(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    while(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        break;\n    }\n    {\n        int fileDesc;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_31_bad()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)malloc(10);\n    if (data == NULL) {exit(-1);}\n    {\n        int * dataCopy = data;\n        int * data = dataCopy;\n        {\n            int source[10] = {0};\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            for (i = 0; i < 10; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            free(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE197_Numeric_Truncation_Error__int_fgets_to_short_12_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__struct_realloc_22_bad()\n{\n    twoIntsStruct * data;\n    data = NULL; /* Initialize data */\n    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */\n    data = (twoIntsStruct *)realloc(data, 1*sizeof(twoIntsStruct));\n    CWE690_NULL_Deref_From_Return__struct_realloc_22_badGlobal = 1; /* true */\n    CWE690_NULL_Deref_From_Return__struct_realloc_22_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE690 - Unchecked Return Value To NULL Pointer"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_54_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_char_listen_socket_41_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_08_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = badSink;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = wcslen(data);\n        /* if there is room in data, read into it from the console */\n        if (FILENAME_MAX-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgetws() */\n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__short_rand_postinc_13_bad()\n{\n    short data;\n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Use a random value */\n        data = (short)RAND32();\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n            data++;\n            short result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_console_execl_08_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory on the heap */\n    data = (wchar_t *)calloc(100, sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    /* Initialize and make use of data */\n    wcscpy(data, L\"A String\");\n    printWLine(data);\n    const CWE401_Memory_Leak__wchar_t_calloc_81_base& baseObject = CWE401_Memory_Leak__wchar_t_calloc_81_bad();\n    baseObject.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Use a small buffer */\n    data = new wchar_t[50];\n    wmemset(data, L'A', 50-1); /* fill with 'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Over-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE176_Improper_Handling_of_Unicode_Encoding__w32_53_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* POTENTIAL FLAW: Initialize data as a large unicode string that will cause a buffer overflow in the bad sink */\n    wcscpy(data, L\"\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\\\\u9580\\\\u961c\\\\u9640\\\\u963f\\\\u963b\\\\u9644\");\n    CWE176_Improper_Handling_of_Unicode_Encoding__w32_53b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE176 - Improper Handling of Unicode Encoding"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__wchar_t_realloc_07_bad()\n{\n    wchar_t * data;\n    data = NULL; /* Initialize data */\n    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */\n    data = (wchar_t *)realloc(data, 20*sizeof(wchar_t));\n    if(staticFive==5)\n    {\n        /* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */\n        wcscpy(data, L\"Initialize\");\n        printWLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE690 - Unchecked Return Value To NULL Pointer"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__twoIntsStruct_malloc_13_bad()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Allocate memory on the heap */\n        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));\n        if (data == NULL) {exit(-1);}\n        /* Initialize and make use of data */\n        data[0].intOne = 0;\n        data[0].intTwo = 0;\n        printStructLine(&data[0]);\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: No deallocation */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_char_environment_51_bad()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            strncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    CWE90_LDAP_Injection__w32_char_environment_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE90 - LDAP Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    badSink(dataVector);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__wchar_t_declare_memmove_01_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    wmemset(dataBuffer, L'A', 100-1);\n    dataBuffer[100-1] = L'\\0';\n    /* FLAW: Set data pointer to before the allocated memory buffer */\n    data = dataBuffer - 8;\n    {\n        wchar_t dest[100];\n        wmemset(dest, L'C', 100-1); /* fill with 'C's */\n        dest[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */\n        memmove(dest, data, 100*sizeof(wchar_t));\n        /* Ensure null termination */\n        dest[100-1] = L'\\0';\n        printWLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_68_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_68_badData = data;\n    CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_68b_badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE680 - Integer Overflow to Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_65_bad()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_65b_badSink;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE484_Omitted_Break_Statement_in_Switch__basic_06_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * &dataRef = data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i].intOne = 1;\n                dataBuffer[i].intTwo = 1;\n            }\n        }\n        data = dataBuffer;\n    }\n    {\n        twoIntsStruct * data = dataRef;\n        printStructLine(&data[0]);\n        /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_65_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_loop_32_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = badSink;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        char dataBuffer;\n        dataBuffer = 'A';\n        data = &dataBuffer;\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_66_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32_spawnv_14_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE197_Numeric_Truncation_Error__short_large_02_bad()\n{\n    short data;\n    /* Initialize data */\n    data = -1;\n    if(1)\n    {\n        /* FLAW: Use a number larger than CHAR_MAX */\n        data = CHAR_MAX + 1;\n    }\n    {\n        /* POTENTIAL FLAW: Convert data to a char, possibly causing a truncation error */\n        char charData = (char)data;\n        printHexCharLine(charData);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE197 - Numeric Truncation Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__short_fscanf_square_68_bad()\n{\n    short data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%hd\", &data);\n    CWE190_Integer_Overflow__short_fscanf_square_68_badData = data;\n    CWE190_Integer_Overflow__short_fscanf_square_68b_badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_06_bad()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_65_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_file_printf_67_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32spawnl_54_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    CWE78_OS_Command_Injection__char_file_w32spawnl_54b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = new char[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_82_base* baseObject = new CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE327_Use_Broken_Crypto__w32_RC5_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            /* Read the password from the console */\n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                password[0] = '\\0';\n            }\n            /* The next 3 lines remove the carriage return from the string that is\n             * inserted by fgets() */\n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            /* Read the data to be decrypted from a file */\n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            /* Try to get a context with and without a new key set */\n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            /* Create Hash handle */\n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            /* Hash the password */\n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            /* Derive a RC5 key from the Hashed password */\n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            /* FLAW: Decrypt using RC5 */\n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            /* Ensure the plaintext is NUL-terminated */\n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            /* Cleanup */\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE327 - Use of a Broken or Risky Cryptographic Algorithm"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE284_Improper_Access_Control__w32_char_CreateFile_02_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_file_fprintf_32_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    int &dataRef = data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    {\n        int data = dataRef;\n        {\n            int i;\n            int * buffer = new int[10];\n            /* initialize buffer */\n            for (i = 0; i < 10; i++)\n            {\n                buffer[i] = 0;\n            }\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n            delete[] buffer;\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[100];\n    wmemset(dataBuffer, L'A', 100-1);\n    dataBuffer[100-1] = L'\\0';\n    /* FLAW: Set data pointer to before the allocated memory buffer */\n    data = dataBuffer - 8;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    badSink(dataVector);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    data = NULL;\n    goto source;\nsource:\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_51_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_11_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = (wchar_t *)malloc(10*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_82_base* baseObject = new CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__wchar_t_realloc_12_bad()\n{\n    wchar_t * data;\n    data = NULL; /* Initialize data */\n    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */\n    data = (wchar_t *)realloc(data, 20*sizeof(wchar_t));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */\n        wcscpy(data, L\"Initialize\");\n        printWLine(data);\n        free(data);\n    }\n    else\n    {\n        /* FIX: Check to see if the memory allocation function was successful before initializing the memory buffer */\n        if (data != NULL)\n        {\n            wcscpy(data, L\"Initialize\");\n            printWLine(data);\n            free(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE690 - Unchecked Return Value To NULL Pointer"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE284_Improper_Access_Control__w32_char_CreateWindowStation_08_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_12_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__short_fscanf_multiply_68_bad()\n{\n    short data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%hd\", &data);\n    CWE191_Integer_Underflow__short_fscanf_multiply_68_badData = data;\n    CWE191_Integer_Underflow__short_fscanf_multiply_68b_badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    data = NULL;\n    CWE401_Memory_Leak__int_calloc_84_bad * badObject = new CWE401_Memory_Leak__int_calloc_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_15_bad()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_fscanf_preinc_12_bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    else\n    {\n        /* FIX: Use a small, non-zero value that will not cause an integer overflow in the sinks */\n        data = 2;\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n    else\n    {\n        /* FIX: Add a check to prevent an overflow from occurring */\n        if (data < INT_MAX)\n        {\n            ++data;\n            int result = data;\n            printIntLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        int * dataBuffer = (int *)ALLOCA(100*sizeof(int));\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i] = 5;\n            }\n        }\n        data = dataBuffer;\n    }\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        static twoIntsStruct dataBuffer[100];\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i].intOne = 1;\n                dataBuffer[i].intTwo = 1;\n            }\n        }\n        data = dataBuffer;\n    }\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__connect_socket_for_loop_07_bad()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read count using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                count = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        {\n            size_t i = 0;\n            /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */\n            for (i = 0; i < (size_t)count; i++)\n            {\n                printLine(\"Hello\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_rand_sub_67_bad()\n{\n    int data;\n    CWE191_Integer_Underflow__int_rand_sub_67_structType myStruct;\n    /* Initialize data */\n    data = 0;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    myStruct.structFirst = data;\n    CWE191_Integer_Underflow__int_rand_sub_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE617_Reachable_Assertion__zero_05_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_wchar_t_environment_41_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_wchar_t_console_13_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    /* Initialize data*/\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        data = NULL;\n        /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n        data = (TwoIntsClass *)realloc(data, 100*sizeof(TwoIntsClass));\n        if (data == NULL) {exit(-1);}\n    }\n    else\n    {\n        /* FIX: Allocate memory using new [] */\n        data = new TwoIntsClass[100];\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        /* POTENTIAL FLAW: Deallocate memory using delete [] - the source memory allocation function may\n         * require a call to free() to deallocate the memory */\n        delete [] data;\n    }\n    else\n    {\n        /* FIX: Free memory using free() */\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    wmemset(dataBadBuffer, L'A', 50-1); /* fill with 'A's */\n    dataBadBuffer[50-1] = L'\\0'; /* null terminate */\n    wmemset(dataGoodBuffer, L'A', 100-1); /* fill with 'A's */\n    dataGoodBuffer[100-1] = L'\\0'; /* null terminate */\n    /* FLAW: Set data pointer to a small buffer */\n    data = dataBadBuffer;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Over-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__listen_socket_malloc_65_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE123_Write_What_Where_Condition__connect_socket_67_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    list<char *> dataList;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    badSink(dataList);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_connect_socket_divide_09_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__wchar_t_scanf_16_bad()\n{\n    while(1)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            wscanf(L\"%99s\\0\", data);\n        }\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE252 - Unchecked Return Value"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int i,j;\n    char * data;\n    /* Initialize data */\n    data = NULL;\n    for(i = 0; i < 1; i++)\n    {\n        data = new char[100];\n        /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */\n        delete [] data;\n    }\n    for(j = 0; j < 1; j++)\n    {\n        /* POTENTIAL FLAW: Possibly deleting memory twice */\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE415 - Double Free"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Use a small buffer */\n    data = new wchar_t[50];\n    wmemset(data, L'A', 50-1); /* fill with 'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Over-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_01_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_max_postinc_13_bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Use the maximum value for this type */\n        data = INT_MAX;\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n            data++;\n            int result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_44_bad()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = badSink;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_environment_popen_06_bad()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                wcsncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        FILE *pipe;\n        /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__char_rand_square_42_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Don't initialize data */\n        ; /* empty statement needed for some flow variants */\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Use data without initializing it */\n        for(int i=0; i<10; i++)\n        {\n            printIntLine(data[i].intOne);\n            printIntLine(data[i].intTwo);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE457 - Use of Uninitialized Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_06_bad()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE617_Reachable_Assertion__fixed_17_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__char_declare_loop_34_bad()\n{\n    char * data;\n    CWE126_Buffer_Overread__char_declare_loop_34_unionType myUnion;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    memset(dataBadBuffer, 'A', 50-1); /* fill with 'A's */\n    dataBadBuffer[50-1] = '\\0'; /* null terminate */\n    memset(dataGoodBuffer, 'A', 100-1); /* fill with 'A's */\n    dataGoodBuffer[100-1] = '\\0'; /* null terminate */\n    /* FLAW: Set data pointer to a small buffer */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            size_t i, destLen;\n            char dest[100];\n            memset(dest, 'C', 100-1);\n            dest[100-1] = '\\0'; /* null terminate */\n            destLen = strlen(dest);\n            /* POTENTIAL FLAW: using length of the dest where data\n             * could be smaller than dest causing buffer overread */\n            for (i = 0; i < destLen; i++)\n            {\n                dest[i] = data[i];\n            }\n            dest[100-1] = '\\0';\n            printLine(dest);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Over-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    map<int, int *> dataMap;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires delete [] to free the memory */\n    data = new int[100];\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_wchar_t_17_bad()\n{\n    int i;\n    wchar_t * password;\n    /* Initialize Data */\n    password = L\"\";\n    for(i = 0; i < 1; i++)\n    {\n        password = (wchar_t *)malloc(100*sizeof(wchar_t));\n        if (password == NULL)\n        {\n            printLine(\"Memory could not be allocated\");\n            exit(1);\n        }\n        /* FLAW: Do not lock the memory */\n        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */\n        wcscpy(password, L\"Password1234!\");\n    }\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n        /* POTENTIAL FLAW: Sensitive data possibly improperly locked */\n        free(password);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE591 - Sensitive Data Storage in Improperly Locked Memory"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_printf_06_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n        printf(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_16_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    data = NULL;\n    if(1)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int[50];\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_wchar_t_connect_socket_14_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        LDAP* pLdapConnection = NULL;\n        ULONG connectSuccess = 0L;\n        ULONG searchSuccess = 0L;\n        LDAPMessage *pMessage = NULL;\n        wchar_t filter[256];\n        /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/\n        _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n        pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n        if (pLdapConnection == NULL)\n        {\n            printLine(\"Initialization failed\");\n            exit(1);\n        }\n        connectSuccess = ldap_connect(pLdapConnection, NULL);\n        if (connectSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Connection failed\");\n            exit(1);\n        }\n        searchSuccess = ldap_search_ext_sW(\n                            pLdapConnection,\n                            L\"base\",\n                            LDAP_SCOPE_SUBTREE,\n                            filter,\n                            NULL,\n                            0,\n                            NULL,\n                            NULL,\n                            LDAP_NO_LIMIT,\n                            LDAP_NO_LIMIT,\n                            &pMessage);\n        if (searchSuccess != LDAP_SUCCESS)\n        {\n            printLine(\"Search failed\");\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            exit(1);\n        }\n        /* Typically you would do something with the search results, but this is a test case and we can ignore them */\n        /* Free the results to avoid incidentals */\n        if (pMessage != NULL)\n        {\n            ldap_msgfree(pMessage);\n        }\n        /* Close the connection */\n        ldap_unbind(pLdapConnection);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE90 - LDAP Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_environment_popen_05_bad()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(staticTrue)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                wcsncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        FILE *pipe;\n        /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    short data;\n    /* Initialize data */\n    data = -1;\n    CWE197_Numeric_Truncation_Error__short_connect_socket_84_bad * badObject = new CWE197_Numeric_Truncation_Error__short_connect_socket_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE197 - Numeric Truncation Error"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE617_Reachable_Assertion__rand_07_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n    }\n    /* POTENTIAL FLAW: this assertion could trigger if n <= ASSERT_VALUE */\n    assert(data > ASSERT_VALUE);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE617 - Reachable Assertion"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__char_fscanf_sub_41_bad()\n{\n    char data;\n    data = ' ';\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%c\", &data);\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_64_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_10_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__malloc_wchar_t_memmove_45_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    short data;\n    short &dataRef = data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (short)RAND32();\n    {\n        short data = dataRef;\n        {\n            /* POTENTIAL FLAW: if (data*data) > SHRT_MAX, this will overflow */\n            short result = data * data;\n            printIntLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n        break;\n    }\n    {\n        int fileDesc;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__malloc_wchar_t_loop_14_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_file_vprintf_52_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    data = badSource(data);\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        wcscat(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (FILENAME_MAX-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            HANDLE hFile;\n            /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n            hFile = CreateFileA(data,\n                                (GENERIC_WRITE|GENERIC_READ),\n                                0,\n                                NULL,\n                                OPEN_ALWAYS,\n                                FILE_ATTRIBUTE_NORMAL,\n                                NULL);\n            if (hFile != INVALID_HANDLE_VALUE)\n            {\n                CloseHandle(hFile);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    data = badSource(data);\n    {\n        ofstream outputFile;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32_spawnv_14_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* spawnv - specify the path where the command is located */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_fgets_preinc_52_bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE190_Integer_Overflow__int_fgets_preinc_52b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_10_bad()\n{\n    char * data;\n    char dataBuffer[250] = \"PATH=\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */\n    PUTENV(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE427 - Uncontrolled Search Path Element"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_console_fprintf_64_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_31_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_file_vfprintf_01_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE328_Reversible_One_Way_Hash__w32_MD5_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            HCRYPTPROV hCryptProv;\n            HCRYPTHASH hHash;\n            FILE *pFile = NULL;\n            char password[PASSWORD_INPUT_SIZE];\n            UCHAR savedHash[MD5_SUM_SIZE], calcHash[MD5_SUM_SIZE];\n            DWORD hashSize;\n            char *replace;\n            size_t i;\n            pFile = fopen(\"password.txt\", \"r\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            for (i = 0; i < MD5_SUM_SIZE; i++)\n            {\n                ULONG val;\n                if (fscanf(pFile, \"%02x\", &val) != 1)\n                {\n                    fclose(pFile);\n                    exit(1);\n                }\n                if (val > 0xff) /* EXPECTED INCIDENTAL: Reliance on data memory layout, we assume char is at least 8 bits */\n                {\n                    fclose(pFile);\n                    exit(1);\n                }\n                savedHash[i] = (UCHAR)val;\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n            if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\n            {\n                exit(1);\n            }\n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\n            {\n                exit(1);\n            }\n            /* FLAW: Use a reversible hash (MD5) */\n            if (!CryptCreateHash(hCryptProv, CALG_MD5, 0, 0, &hHash))\n            {\n                CryptReleaseContext(hCryptProv, 0);\n                exit(1);\n            }\n            /* EXPECTED INCIDENTAL: We did not salt the password, that may raise flags,\n             * the password hash was not securely transmitted (via one form or another),\n             * that may raise flags\n             */\n            if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\n            {\n                CryptDestroyHash(hHash);\n                CryptReleaseContext(hCryptProv, 0);\n                exit(1);\n            }\n            hashSize = MD5_SUM_SIZE;\n            if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\n            {\n                CryptDestroyHash(hHash);\n                CryptReleaseContext(hCryptProv, 0);\n                exit(1);\n            }\n            if (memcmp(savedHash, calcHash, MD5_SUM_SIZE * sizeof(UCHAR)) == 0)\n            {\n                printLine(\"Access granted\");\n            }\n            else\n            {\n                printLine(\"Access denied\");\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n        }\n    }\n    else\n    {\n        {\n            HCRYPTPROV hCryptProv;\n            HCRYPTHASH hHash;\n            FILE *pFile = NULL;\n            char password[PASSWORD_INPUT_SIZE];\n            UCHAR savedHash[SHA512_SUM_SIZE], calcHash[SHA512_SUM_SIZE];\n            DWORD hashSize;\n            char *replace;\n            size_t i;\n            pFile = fopen(\"password.txt\", \"r\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            for (i = 0; i < SHA512_SUM_SIZE; i++)\n            {\n                ULONG val;\n                if (fscanf(pFile, \"%02x\", &val) != 1)\n                {\n                    fclose(pFile);\n                    exit(1);\n                }\n                if (val > 0xff) /* EXPECTED INCIDENTAL: Reliance on data memory layout, we assume char is at least 8 bits */\n                {\n                    fclose(pFile);\n                    exit(1);\n                }\n                savedHash[i] = (UCHAR)val;\n            }\n            fclose(pFile);\n            if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL)\n            {\n                exit(1);\n            }\n            replace = strchr(password, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(password, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            if (!CryptAcquireContextW(&hCryptProv, 0, 0, PROV_RSA_FULL, 0))\n            {\n                exit(1);\n            }\n            /* FIX: use a non-reversible hash (SHA-512) */\n            if (!CryptCreateHash(hCryptProv, CALG_SHA_512, 0, 0, &hHash))\n            {\n                CryptReleaseContext(hCryptProv, 0);\n                exit(1);\n            }\n            /* EXPECTED INCIDENTAL: We did not salt the password, that may raise flags,\n             * the password hash was not securely transmitted (via one form or another),\n             * that may raise flags\n             */\n            if (!CryptHashData(hHash, (BYTE*)password, strlen(password), 0))\n            {\n                CryptDestroyHash(hHash);\n                CryptReleaseContext(hCryptProv, 0);\n                exit(1);\n            }\n            hashSize = SHA512_SUM_SIZE;\n            if (!CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)calcHash, &hashSize, 0))\n            {\n                CryptDestroyHash(hHash);\n                CryptReleaseContext(hCryptProv, 0);\n                exit(1);\n            }\n            if (memcmp(savedHash, calcHash, SHA512_SUM_SIZE * sizeof(UCHAR)) == 0)\n            {\n                printLine(\"Access granted\");\n            }\n            else\n            {\n                printLine(\"Access denied\");\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE328 - Reversible One Way Hash"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_06_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_environment_w32spawnl_13_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    /* spawnl - specify the path where the command is located */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_rand_divide_44_bad()\n{\n    int data;\n    /* define a function pointer */\n    void (*funcPtr) (int) = badSink;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        twoIntsStruct * dataBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i].intOne = 1;\n                dataBuffer[i].intTwo = 1;\n            }\n        }\n        data = dataBuffer;\n    }\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_12_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    else\n    {\n        /* FIX: Append a fixed string to data (not user / external input) */\n        wcscat(data, L\"*.*\");\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    structType myStruct;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    myStruct.structFirst = data;\n    badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_fscanf_preinc_12_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_char_listen_socket_41_bad()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE90_LDAP_Injection__w32_char_listen_socket_41_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE90 - LDAP Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        ofstream outputFile;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_rand_multiply_34_bad()\n{\n    int data;\n    CWE190_Integer_Overflow__int_rand_multiply_34_unionType myUnion;\n    /* Initialize data */\n    data = 0;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    myUnion.unionFirst = data;\n    {\n        int data = myUnion.unionSecond;\n        if(data > 0) /* ensure we won't have an underflow */\n        {\n            /* POTENTIAL FLAW: if (data*2) > INT_MAX, this will overflow */\n            int result = data * 2;\n            printIntLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE390_Error_Without_Action__fgets_wchar_t_14_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires delete to free the memory */\n    data = new char;\n    CWE762_Mismatched_Memory_Management_Routines__new_delete_array_char_82_base* baseObject = new CWE762_Mismatched_Memory_Management_Routines__new_delete_array_char_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__int64_t_realloc_65_bad()\n{\n    int64_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (int64_t *) = CWE690_NULL_Deref_From_Return__int64_t_realloc_65b_badSink;\n    data = NULL; /* Initialize data */\n    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */\n    data = (int64_t *)realloc(data, 1*sizeof(int64_t));\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE690 - Unchecked Return Value To NULL Pointer"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_16_bad()\n{\n    wchar_t * data;\n    data = NULL;\n    while(1)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = (wchar_t *)malloc(10*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_char_connect_socket_34_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    /* Initialize data*/\n    data = NULL;\n    CWE762_Mismatched_Memory_Management_Routines__delete_int_calloc_83_bad badObject(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_01_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__negative_memcpy_08_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    /* Initialize data */\n    data = NULL;\n    if(1)\n    {\n        data = new int64_t[100];\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5LL;\n            }\n        }\n        /* POTENTIAL FLAW: Delete data in the source - the bad sink attempts to use data */\n        delete [] data;\n    }\n    if(1)\n    {\n        /* POTENTIAL FLAW: Use of data that may have been deleted */\n        printLongLongLine(data[0]);\n        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not deleted */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE416 - Use After Free"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_18_bad()\n{\n    wchar_t * data;\n    data = (wchar_t *)malloc(100*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    data[0] = L'\\0';\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    goto sink;\nsink:\n    /* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\n     * memory block not at the start of the buffer */\n    for (; *data != L'\\0'; data++)\n    {\n        if (*data == SEARCH_CHAR)\n        {\n            printLine(\"We have a match!\");\n            break;\n        }\n    }\n    free(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE761 - Free Pointer not at Start of Buffer"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_10_bad()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(globalTrue)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE129_large_04_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Use an invalid index */\n        data = 10;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            int i;\n            int * buffer = (int *)malloc(10 * sizeof(int));\n            if (buffer == NULL) {exit(-1);}\n            /* initialize buffer */\n            for (i = 0; i < 10; i++)\n            {\n                buffer[i] = 0;\n            }\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n             * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n            free(buffer);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    badSource(data);\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_fscanf_add_01_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE366_Race_Condition_Within_Thread__int_byref_10_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_04_bad()\n{\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: putchar() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (putchar((int)'A') == 0)\n        {\n            printLine(\"putchar failed!\");\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE253 - Incorrect Check of Return Value"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE197_Numeric_Truncation_Error__int_fgets_to_short_12_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    else\n    {\n        /* FIX: Use a positive integer less than CHAR_MAX*/\n        data = CHAR_MAX-5;\n    }\n    {\n        /* POTENTIAL FLAW: Convert data to a short, possibly causing a truncation error */\n        short shortData = (short)data;\n        printShortLine(shortData);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE197 - Numeric Truncation Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_06_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__connect_socket_malloc_63_bad()\n{\n    short data;\n    /* Initialize data */\n    data = 0;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        int tempInt;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* FLAW: Use a value input from the network */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to short - ensure int to short conversion will be successful and if\n             * not ensure that data will be negative */\n            tempInt = atoi(inputBuffer);\n            if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)\n            {\n                data = -1;\n            }\n            else\n            {\n                data = tempInt;\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE194_Unexpected_Sign_Extension__connect_socket_malloc_63b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    data = NULL; /* Initialize data */\n    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */\n    data = (long *)realloc(data, 1*sizeof(long));\n    CWE690_NULL_Deref_From_Return__long_realloc_82_base* baseObject = new CWE690_NULL_Deref_From_Return__long_realloc_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE690 - Unchecked Return Value To NULL Pointer"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__float_rand_67_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_03_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(5==5)\n    {\n        badVaSinkB(data, data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    float data;\n    /* Initialize data */\n    data = 0.0F;\n    badSource(data);\n    {\n        /* POTENTIAL FLAW: Possibly divide by zero */\n        int result = (int)(100.0 / data);\n        printIntLine(result);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int i;\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_05_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__malloc_wchar_t_loop_14_bad()\n{\n    wchar_t * data;\n    data = NULL;\n    if(globalFive==5)\n    {\n        /* FLAW: Use a small buffer */\n        data = (wchar_t *)malloc(50*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n        wmemset(data, L'A', 50-1); /* fill with 'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i, destLen;\n        wchar_t dest[100];\n        wmemset(dest, L'C', 100-1);\n        dest[100-1] = L'\\0'; /* null terminate */\n        destLen = wcslen(dest);\n        /* POTENTIAL FLAW: using length of the dest where data\n         * could be smaller than dest causing buffer overread */\n        for (i = 0; i < destLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[100-1] = L'\\0';\n        printWLine(dest);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Over-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        int fileDesc;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__char_declare_memmove_66_bad()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100];\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    /* FLAW: Set data pointer to before the allocated memory buffer */\n    data = dataBuffer - 8;\n    /* put data in array */\n    dataArray[2] = data;\n    CWE124_Buffer_Underwrite__char_declare_memmove_66b_badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_31_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    badStatic = 1; /* true */\n    data = badSource(data);\n    {\n        int fileDesc;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n    ;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncat_51_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__connect_socket_for_loop_52_bad()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read count using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE400_Resource_Exhaustion__connect_socket_for_loop_52b_badSink(count);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE284_Improper_Access_Control__w32_wchar_t_CreateWindowStation_18_bad()\n{\n    goto sink;\nsink:\n    {\n        HWINSTA hWinStation;\n        wchar_t * wStationName = L\"WindowsStationExample\";\n        /* FLAW: Call CreateWindowStationW() with GENERIC_ALL as the 3rd parameter */\n        hWinStation = CreateWindowStationW(\n                          wStationName,\n                          0,\n                          GENERIC_ALL,\n                          NULL);\n        if (hWinStation == NULL)\n        {\n            printLine(\"Windows station could not be created\");\n        }\n        else\n        {\n            printLine(\"Windows Station created successfully\");\n            CloseWindowStation(hWinStation);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE284 - Improper Access Control"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Use a small buffer */\n    data = new char[50];\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Over-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        static char dataBuffer[100];\n        memset(dataBuffer, 'A', 100-1); /* fill with 'A's */\n        dataBuffer[100-1] = '\\0'; /* null terminate */\n        data = dataBuffer;\n    }\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_rand_postinc_68_bad()\n{\n    unsigned int data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    CWE190_Integer_Overflow__unsigned_int_rand_postinc_68_badData = data;\n    CWE190_Integer_Overflow__unsigned_int_rand_postinc_68b_badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    {\n        ofstream outputFile;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        outputFile.open((char *)data);\n        outputFile.close();\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE482_Comparing_Instead_of_Assigning__basic_16_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_wchar_t_declare_05_bad()\n{\n    wchar_t * data;\n    data = NULL; /* Initialize data */\n    if(staticTrue)\n    {\n        {\n            /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n            wchar_t dataBuffer[100];\n            wmemset(dataBuffer, L'A', 100-1); /* fill with 'A's */\n            dataBuffer[100-1] = L'\\0'; /* null terminate */\n            data = dataBuffer;\n        }\n    }\n    printWLine(data);\n    /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */\n    free(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32_execv_63_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    CWE78_OS_Command_Injection__char_file_w32_execv_63b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_08_bad()\n{\n    int * data;\n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = (int *)malloc(50*sizeof(int));\n        if (data == NULL) {exit(-1);}\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE675_Duplicate_Operations_on_Resource__freopen_54_bad()\n{\n    FILE * data;\n    data = NULL; /* Initialize data */\n    data = freopen(\"BadSource_freopen.txt\",\"w+\",stdin);\n    /* POTENTIAL FLAW: Close the file in the source */\n    fclose(data);\n    CWE675_Duplicate_Operations_on_Resource__freopen_54b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE675 - Duplicate Operations on Resource"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_environment_w32_execvp_67_bad()\n{\n    wchar_t * data;\n    CWE78_OS_Command_Injection__wchar_t_environment_w32_execvp_67_structType myStruct;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    myStruct.structFirst = data;\n    CWE78_OS_Command_Injection__wchar_t_environment_w32_execvp_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE197_Numeric_Truncation_Error__short_large_02_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_03_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_31_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        size_t dataBytes,i;\n        int *intPointer;\n        /* POTENTIAL FLAW: dataBytes may overflow to a small value */\n        dataBytes = data * sizeof(int); /* sizeof array in bytes */\n        intPointer = (int*)new char[dataBytes];\n        for (i = 0; i < (size_t)data; i++)\n        {\n            intPointer[i] = 0; /* may write beyond limit of intPointer if integer overflow occured above */\n        }\n        printIntLine(intPointer[0]);\n        delete [] intPointer;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE680 - Integer Overflow to Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_w32CreateFile_68_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_console_snprintf_04_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = wcslen(data);\n            /* if there is room in data, read into it from the console */\n            if (100-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgetws() */\n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            wchar_t dest[100] = L\"\";\n            /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n            SNPRINTF(dest, 100-1, data);\n            printWLine(dest);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE226_Sensitive_Information_Uncleared_Before_Release__w32_wchar_t_declare_17_bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            wchar_t password[100] = L\"\";\n            size_t passwordLen = 0;\n            HANDLE hUser;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            if (fgetws(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                password[0] = L'\\0';\n            }\n            /* Remove the carriage return from the string that is inserted by fgetws() */\n            passwordLen = wcslen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = L'\\0';\n            }\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &hUser) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(hUser);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n            /* FLAW: Release password from the stack without first clearing the buffer */\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE226 - Sensitive Information Uncleared Before Release"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68_bad()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68_badData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68b_badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_11_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__long_malloc_13_good()\n{\n    goodB2G1();\n    goodB2G2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_file_fprintf_12_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__wchar_t_declare_memmove_01_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    const CWE369_Divide_by_Zero__int_listen_socket_modulo_81_base& baseObject = CWE369_Divide_by_Zero__int_listen_socket_modulo_81_bad();\n    baseObject.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__unsigned_int_fscanf_predec_04_bad()\n{\n    unsigned int data;\n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Use a value input from the console */\n        fscanf (stdin, \"%u\", &data);\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* POTENTIAL FLAW: Decrementing data could cause an underflow */\n            --data;\n            unsigned int result = data;\n            printUnsignedLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_17_bad()\n{\n    int i;\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long data;\n    long &dataRef = data;\n    /* POTENTIAL FLAW: Initialize, but do not use data */\n    data = 5L;\n    {\n        long data = dataRef;\n        /* FLAW: Do not use the variable */\n        /* do nothing */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE563 - Unused Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__char_declare_memmove_66_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_console_w32_spawnv_52_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_fscanf_square_68_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE482_Comparing_Instead_of_Assigning__basic_16_bad()\n{\n    while(1)\n    {\n        {\n            int intBadSink = 0;\n            /* Print original value to avoid any unused variable incidentals */\n            printIntLine(intBadSink);\n            /* FLAW: meant to assign 5 to intBadSink.  Maintenance note: may generate a compiler warning, this is intentional */\n            intBadSink == 5;\n            printIntLine(intBadSink);\n        }\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE482 - Comparing Instead of Assigning"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__struct_twoIntsStruct_realloc_18_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_file_fprintf_32_bad()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        {\n            /* Read input from a file */\n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        /* Restore NUL terminator if fgetws fails */\n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n        fwprintf(stdout, data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fscanf_divide_45_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE369_Divide_by_Zero__int_fscanf_divide_45_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_environment_w32_execv_04_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        /* Restore NUL terminator if fgetws fails */\n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    else\n    {\n#ifdef _WIN32\n        /* FIX: Use a fixed, full path and file name */\n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        /* FIX: Use a fixed, full path and file name */\n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        ifstream inputFile;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_rand_add_51_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__connect_socket_malloc_63_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE617_Reachable_Assertion__zero_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: this assertion can be reached, and will always trigger */\n        assert(0); /* INCIDENTAL: CWE 571 - expression is always true - it's \"true\" because assert(e) basically does if (!(e)) */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE617 - Reachable Assertion"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_34_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_21_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__connect_socket_for_loop_64_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__fopen_44_bad()\n{\n    FILE * data;\n    /* define a function pointer */\n    void (*funcPtr) (FILE *) = badSink;\n    /* Initialize data */\n    data = NULL;\n    /* POTENTIAL FLAW: Open a file without checking the return value for NULL */\n    data = fopen(\"file.txt\", \"w+\");\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE690 - Unchecked Return Value To NULL Pointer"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_04_good()\n{\n    goodB2G1();\n    goodB2G2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_rand_add_51_bad()\n{\n    int64_t data;\n    data = 0LL;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (int64_t)RAND64();\n    CWE190_Integer_Overflow__int64_t_rand_add_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    /* Initialize data*/\n    data = NULL;\n    if(globalTrue)\n    {\n        /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n        data = (int *)calloc(100, sizeof(int));\n        if (data == NULL) {exit(-1);}\n    }\n    if(globalTrue)\n    {\n        /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may\n         * require a call to free() to deallocate the memory */\n        delete data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_02_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    /* wspawnlp - searches for the location of the command among\n     * the directories specified by the PATH environment variable */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32_execv_63_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE15_External_Control_of_System_or_Configuration_Setting__w32_54_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        int recvResult;\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            /* INCIDENTAL CWE 188 - reliance on data memory layout\n             * recv and friends return \"number of bytes\" received\n             * char's on our system, however, may not be \"octets\" (8-bit\n             * bytes) but could be just about anything.  Also,\n             * even if the external environment is ASCII or UTF8,\n             * the ANSI/ISO C standard does not dictate that the\n             * character set used by the actual language or character\n             * constants matches.\n             *\n             * In practice none of these are usually issues...\n             */\n            /* FLAW: read the new hostname from a network socket */\n            recvResult = recv(acceptSocket, data, 100 - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            data[recvResult] = '\\0';\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    CWE15_External_Control_of_System_or_Configuration_Setting__w32_54b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE15 - External Control of System or Configuration Setting"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    structType myStruct;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__strdup_wchar_t_61_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    /* Initialize data*/\n    data = NULL;\n    {\n        char myString[] = \"myString\";\n        /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */\n        data = strdup(myString);\n    }\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_18_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_44_bad()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *, ...) = badVaSink;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* use the function pointer */\n    funcPtr(data, data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_08_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE617_Reachable_Assertion__zero_05_bad()\n{\n    if(staticTrue)\n    {\n        /* FLAW: this assertion can be reached, and will always trigger */\n        assert(0); /* INCIDENTAL: CWE 571 - expression is always true - it's \"true\" because assert(e) basically does if (!(e)) */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE617 - Reachable Assertion"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE675_Duplicate_Operations_on_Resource__freopen_54_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_fscanf_square_04_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_31_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FLAW: Use a negative number */\n    data = -1;\n    {\n        int dataCopy = data;\n        int data = dataCopy;\n        {\n            char source[100];\n            char dest[100] = \"\";\n            memset(source, 'A', 100-1);\n            source[100-1] = '\\0';\n            if (data < 100)\n            {\n                /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\n                 * the sign conversion could result in a very large number */\n                memmove(dest, source, data);\n                dest[data] = '\\0'; /* NULL terminate */\n            }\n            printLine(dest);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_13_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnv - specify the path where the command is located */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_18_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_environment_w32_execv_04_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* execv - specify the path where the command is located */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        EXECV(COMMAND_INT_PATH, args);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__rand_strncpy_09_bad()\n{\n    short data;\n    /* Initialize data */\n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Use a random value that could be less than 0 */\n        data = (short)RAND32();\n    }\n    {\n        char source[100];\n        char dest[100] = \"\";\n        memset(source, 'A', 100-1);\n        source[100-1] = '\\0';\n        if (data < 100)\n        {\n            /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\n             * the sign extension could result in a very large number */\n            strncpy(dest, source, data);\n            dest[data] = '\\0'; /* strncpy() does not always NULL terminate */\n        }\n        printLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__wchar_t_declare_loop_15_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    /* Initialize data*/\n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Allocate memory with a function that requires delete to free the memory */\n        data = new twoIntsStruct;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Deallocate memory using free() - the source memory allocation function may\n         * require a call to delete to deallocate the memory */\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_console_w32spawnl_14_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32_spawnv_52_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = strlen(data);\n            /* if there is room in data, read into it from the console */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgets() */\n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__wchar_t_declare_loop_68_bad()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    wmemset(dataBadBuffer, L'A', 50-1); /* fill with 'A's */\n    dataBadBuffer[50-1] = L'\\0'; /* null terminate */\n    wmemset(dataGoodBuffer, L'A', 100-1); /* fill with 'A's */\n    dataGoodBuffer[100-1] = L'\\0'; /* null terminate */\n    /* FLAW: Set data pointer to a small buffer */\n    data = dataBadBuffer;\n    CWE126_Buffer_Overread__wchar_t_declare_loop_68_badData = data;\n    CWE126_Buffer_Overread__wchar_t_declare_loop_68b_badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Over-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    /* Initialize data */\n    data = NULL;\n    data = new TwoIntsClass[100];\n    /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */\n    delete [] data;\n    badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE415 - Double Free"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            try\n            {\n                string stringHello = \"hello\";\n                string stringSubstring = stringHello.substr(rand(), rand());\n                printLine(stringSubstring.c_str());\n            }\n            catch (out_of_range &)\n            {\n                /* FLAW: Catch, but do not handle the out_of_range error */\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE390 - Error Without Action"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__short_fscanf_predec_17_bad()\n{\n    int i,j;\n    short data;\n    data = 0;\n    for(i = 0; i < 1; i++)\n    {\n        /* POTENTIAL FLAW: Use a value input from the console */\n        fscanf (stdin, \"%hd\", &data);\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* POTENTIAL FLAW: Decrementing data could cause an underflow */\n            --data;\n            short result = data;\n            printIntLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = strlen(data);\n            /* if there is room in data, read into it from the console */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgets() */\n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n        break;\n    }\n    {\n        FILE *pFile = NULL;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_17_bad()\n{\n    int i;\n    int * data;\n    data = NULL;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    /* Initialize data*/\n    data = NULL;\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (int *)realloc(data, 100*sizeof(int));\n    if (data == NULL) {exit(-1);}\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fscanf_modulo_68_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE369_Divide_by_Zero__int_fscanf_modulo_68_badData = data;\n    CWE369_Divide_by_Zero__int_fscanf_modulo_68b_badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_04_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    list<int>  data;\n    list<list<int> > dataList;\n    /* POTENTIAL FLAW: Insert a zero into the list */\n    data.push_back(100);\n    data.push_back(0);\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    badSink(dataList);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE672 - Operation on Resource After Expiration or Release"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int count;\n    map<int, int> countMap;\n    /* Initialize count */\n    count = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read count from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            count = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    /* Put count in a map */\n    countMap[0] = count;\n    countMap[1] = count;\n    countMap[2] = count;\n    badSink(countMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_14_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_console_snprintf_04_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_51_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE327_Use_Broken_Crypto__w32_RC5_16_bad()\n{\n    while(1)\n    {\n        {\n            FILE *pFile;\n            HCRYPTPROV hCryptProv;\n            HCRYPTKEY hKey;\n            HCRYPTHASH hHash;\n            char password[100];\n            size_t passwordLen;\n            char toBeDecrypted[100];\n            DWORD toBeDecryptedLen = sizeof(toBeDecrypted)-1;\n            /* Read the password from the console */\n            printLine(\"Enter the password: \");\n            if (fgets(password, 100, stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                password[0] = '\\0';\n            }\n            /* The next 3 lines remove the carriage return from the string that is\n             * inserted by fgets() */\n            passwordLen = strlen(password);\n            if (passwordLen > 0)\n            {\n                password[passwordLen-1] = '\\0';\n            }\n            /* Read the data to be decrypted from a file */\n            pFile = fopen(\"encrypted.txt\", \"rb\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            if (fread(toBeDecrypted, sizeof(char), 100, pFile) != 100)\n            {\n                fclose(pFile);\n                exit(1);\n            }\n            toBeDecrypted[99] = '\\0';\n            /* Try to get a context with and without a new key set */\n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n                {\n                    printLine(\"Error in acquiring cryptographic context\");\n                    exit(1);\n                }\n            }\n            /* Create Hash handle */\n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                printLine(\"Error in creating hash\");\n                exit(1);\n            }\n            /* Hash the password */\n            if(!CryptHashData(hHash, (BYTE *) password, passwordLen, 0))\n            {\n                printLine(\"Error in hashing password\");\n                exit(1);\n            }\n            /* Derive a RC5 key from the Hashed password */\n            if(!CryptDeriveKey(hCryptProv, CALG_RC5, hHash, 0, &hKey))\n            {\n                printLine(\"Error in CryptDeriveKey\");\n                exit(1);\n            }\n            /* FLAW: Decrypt using RC5 */\n            if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)toBeDecrypted, &toBeDecryptedLen))\n            {\n                printLine(\"Error in decryption\");\n                exit(1);\n            }\n            /* Ensure the plaintext is NUL-terminated */\n            toBeDecrypted[toBeDecryptedLen] = '\\0';\n            printLine(toBeDecrypted);\n            /* Cleanup */\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE327 - Use of a Broken or Risky Cryptographic Algorithm"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE427_Uncontrolled_Search_Path_Element__wchar_t_environment_04_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_31_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_66_bad()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    data = NULL;\n    {\n        wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\n        if (dataBuffer == NULL) {exit(-1);}\n        wmemset(dataBuffer, L'A', 100-1);\n        dataBuffer[100-1] = L'\\0';\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_66b_badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        /* Restore NUL terminator if fgetws fails */\n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        int fileDesc;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__rand_strncpy_09_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__listen_socket_for_loop_22_bad()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read count using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE400_Resource_Exhaustion__listen_socket_for_loop_22_badGlobal = 1; /* true */\n    CWE400_Resource_Exhaustion__listen_socket_for_loop_22_badSink(count);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE775_Missing_Release_of_File_Descriptor_or_Handle__w32CreateFile_no_close_53_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    CWE426_Untrusted_Search_Path__wchar_t_system_84_bad * badObject = new CWE426_Untrusted_Search_Path__wchar_t_system_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE426 - Untrusted Search Path"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE377_Insecure_Temporary_File__wchar_t_mktemp_12_bad()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            wchar_t * filename;\n            wchar_t tmpl[] = L\"fnXXXXXX\";\n            int fileDesc;\n            filename = MKTEMP(tmpl);\n            if (filename == NULL)\n            {\n                exit(1);\n            }\n            printWLine(filename);\n            /* FLAW: Open a temporary file using open() and flags that do not prevent a race condition */\n            fileDesc = OPEN(filename, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n            if (fileDesc != -1)\n            {\n                printLine(\"Temporary file was opened...now closing file\");\n                CLOSE(fileDesc);\n            }\n        }\n    }\n    else\n    {\n        {\n            wchar_t * filename;\n            wchar_t tmpl[] = L\"fnXXXXXX\";\n            int fileDesc;\n            filename = MKTEMP(tmpl);\n            if (filename == NULL)\n            {\n                exit(1);\n            }\n            printWLine(filename);\n            /* FIX: Open a temporary file using open() and the O_CREAT and O_EXCL flags\n            * NOTE: This is not a perfect solution, but it is the base case scenario */\n            fileDesc = OPEN(filename, O_RDWR|O_CREAT|O_EXCL, S_IREAD|S_IWRITE);\n            if (fileDesc != -1)\n            {\n                printLine(\"Temporary file was opened...now closing file\");\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE377 - Insecure Temporary File"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_09_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fgets_divide_41_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__malloc_wchar_t_loop_53_bad()\n{\n    wchar_t * data;\n    data = NULL;\n    {\n        wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));\n        if (dataBuffer == NULL) {exit(-1);}\n        wmemset(dataBuffer, L'A', 100-1);\n        dataBuffer[100-1] = L'\\0';\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    CWE127_Buffer_Underread__malloc_wchar_t_loop_53b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    badSource(data);\n    {\n        char dest[100] = \"\";\n        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n        SNPRINTF(dest, 100-1, data);\n        printLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_console_w32_spawnv_52_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    CWE78_OS_Command_Injection__char_console_w32_spawnv_52b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__wchar_t_fputs_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Do not check the return value */\n        fputws(L\"string\", stdout);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE252 - Unchecked Return Value"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_console_vfprintf_34_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        badVaSink(data, data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_02_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__listen_socket_sleep_65_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_environment_popen_10_bad()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(globalTrue)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        FILE *pipe;\n        /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_53_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_53b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    CWE78_OS_Command_Injection__char_environment_w32_spawnv_83_bad badObject(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct data;\n    vector<twoIntsStruct> dataVector;\n    /* POTENTIAL FLAW: Initialize, but do not use data */\n    data.intOne = 0;\n    data.intTwo = 0;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    badSink(dataVector);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE563 - Unused Variable"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    unionType myUnion;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            ifstream inputFile;\n            /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n            inputFile.open((char *)data);\n            inputFile.close();\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    /* Initialize data*/\n    data = NULL;\n    if(globalReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n        data = (long *)malloc(100*sizeof(long));\n        if (data == NULL) {exit(-1);}\n    }\n    if(globalReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may\n         * require a call to free() to deallocate the memory */\n        delete data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_char_console_64_bad()\n{\n    char * data;\n    char dataBuffer[256] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (256-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    CWE90_LDAP_Injection__w32_char_console_64b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE90 - LDAP Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    data = NULL; /* Initialize data */\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n            int64_t dataBuffer[100];\n            {\n                size_t i;\n                for (i = 0; i < 100; i++)\n                {\n                    dataBuffer[i] = 5LL;\n                }\n            }\n            data = dataBuffer;\n        }\n    }\n    printLongLongLine(data[0]);\n    /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */\n    delete [] data;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_09_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n        fprintf(stdout, data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__wchar_t_declare_cpy_04_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    wmemset(dataBuffer, L'A', 100-1);\n    dataBuffer[100-1] = L'\\0';\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    {\n        wchar_t dest[100*2];\n        wmemset(dest, L'C', 100*2-1); /* fill with 'C's */\n        dest[100*2-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */\n        wcscpy(dest, data);\n        printWLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_connect_socket_divide_09_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Possibly divide by zero */\n        printIntLine(100 / data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_53_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_11_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__float_fgets_51_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_console_execl_08_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = strlen(data);\n            /* if there is room in data, read into it from the console */\n            if (100-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgets() */\n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    /* execl - specify the path where the command is located */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__malloc_char_memmove_12_bad()\n{\n    char * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char * dataBuffer = (char *)malloc(100*sizeof(char));\n            if (dataBuffer == NULL) {exit(-1);}\n            memset(dataBuffer, 'A', 100-1);\n            dataBuffer[100-1] = '\\0';\n            /* FLAW: Set data pointer to before the allocated memory buffer */\n            data = dataBuffer - 8;\n        }\n    }\n    else\n    {\n        {\n            char * dataBuffer = (char *)malloc(100*sizeof(char));\n            if (dataBuffer == NULL) {exit(-1);}\n            memset(dataBuffer, 'A', 100-1);\n            dataBuffer[100-1] = '\\0';\n            /* FIX: Set data pointer to the allocated memory buffer */\n            data = dataBuffer;\n        }\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        memmove(data, source, 100*sizeof(char));\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n         * returned by malloc() so can't safely call free() on it */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE426_Untrusted_Search_Path__char_system_18_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FLAW: the full path is not specified */\n    strcpy(data, BAD_OS_COMMAND);\n    /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable\n     * can allow an attacker to run their own program */\n    if (SYSTEM(data) <= 0)\n    {\n        printLine(\"command execution failed!\");\n        exit(1);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE426 - Untrusted Search Path"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_loop_02_bad()\n{\n    char * data;\n    data = (char *)malloc(100*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    if(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_06_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_rand_multiply_64_bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE190_Integer_Overflow__int_rand_multiply_64b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__malloc_char_memcpy_53_bad()\n{\n    char * data;\n    data = NULL;\n    {\n        char * dataBuffer = (char *)malloc(100*sizeof(char));\n        if (dataBuffer == NULL) {exit(-1);}\n        memset(dataBuffer, 'A', 100-1);\n        dataBuffer[100-1] = '\\0';\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    CWE127_Buffer_Underread__malloc_char_memcpy_53b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE468_Incorrect_Pointer_Scaling__int_09_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__wchar_t_declare_loop_11_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    wmemset(dataBuffer, L'A', 100-1);\n    dataBuffer[100-1] = L'\\0';\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with 'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = L'\\0';\n        printWLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int i;\n    char * data;\n    data = new char[100];\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (FILENAME_MAX-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    CWE23_Relative_Path_Traversal__char_console_w32CreateFile_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_console_w32CreateFile_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_bad()\n{\n    wchar_t * password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE319 - Cleartext Transmission of Sensitive Information"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__int64_t_malloc_13_bad()\n{\n    int64_t * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Allocate memory on the heap */\n        data = (int64_t *)malloc(100*sizeof(int64_t));\n        if (data == NULL) {exit(-1);}\n        /* Initialize and make use of data */\n        data[0] = 5LL;\n        printLongLongLine(data[0]);\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: No deallocation */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    badSource(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        strncpy(data, source, 100-1);\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n         * returned by malloc() so can't safely call free() on it */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_65_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int i;\n    twoIntsStruct * data;\n    data = NULL; /* Initialize data */\n    for(i = 0; i < 1; i++)\n    {\n        {\n            /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n            twoIntsStruct dataBuffer;\n            dataBuffer.intOne = 1;\n            dataBuffer.intTwo = 1;\n            data = &dataBuffer;\n        }\n    }\n    printStructLine(data);\n    /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */\n    delete data;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_fscanf_add_66_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32_execvp_04_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* execvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_listen_socket_sub_66_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_04_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_18_bad()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    goto source;\nsource:\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32_spawnv_52_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    CWE78_OS_Command_Injection__char_file_w32_spawnv_52b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_system_08_bad()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(staticReturnsTrue())\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n    if (SYSTEM(data) != 0)\n    {\n        printLine(\"command execution failed!\");\n        exit(1);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__char_fscanf_sub_41_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_wchar_t_environment_32_bad()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                wcsncat(data+dataLen, environment, 256-dataLen-1);\n            }\n        }\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            LDAP* pLdapConnection = NULL;\n            ULONG connectSuccess = 0L;\n            ULONG searchSuccess = 0L;\n            LDAPMessage *pMessage = NULL;\n            wchar_t filter[256];\n            /* POTENTIAL FLAW: data concatenated into LDAP search, which could result in LDAP Injection*/\n            _snwprintf(filter, 256-1, L\"(cn=%s)\", data);\n            pLdapConnection = ldap_initW(L\"localhost\", LDAP_PORT);\n            if (pLdapConnection == NULL)\n            {\n                printLine(\"Initialization failed\");\n                exit(1);\n            }\n            connectSuccess = ldap_connect(pLdapConnection, NULL);\n            if (connectSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Connection failed\");\n                exit(1);\n            }\n            searchSuccess = ldap_search_ext_sW(\n                                pLdapConnection,\n                                L\"base\",\n                                LDAP_SCOPE_SUBTREE,\n                                filter,\n                                NULL,\n                                0,\n                                NULL,\n                                NULL,\n                                LDAP_NO_LIMIT,\n                                LDAP_NO_LIMIT,\n                                &pMessage);\n            if (searchSuccess != LDAP_SUCCESS)\n            {\n                printLine(\"Search failed\");\n                if (pMessage != NULL)\n                {\n                    ldap_msgfree(pMessage);\n                }\n                exit(1);\n            }\n            /* Typically you would do something with the search results, but this is a test case and we can ignore them */\n            /* Free the results to avoid incidentals */\n            if (pMessage != NULL)\n            {\n                ldap_msgfree(pMessage);\n            }\n            /* Close the connection */\n            ldap_unbind(pLdapConnection);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE90 - LDAP Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_fgets_postinc_65_bad()\n{\n    int data;\n    /* define a function pointer */\n    void (*funcPtr) (int) = CWE190_Integer_Overflow__int_fgets_postinc_65b_badSink;\n    /* Initialize data */\n    data = 0;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_wchar_t_environment_32_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_64_bad()\n{\n    wchar_t * data;\n    data = (wchar_t *)malloc(100*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_64b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_char_console_64_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_63_bad()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_63b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_63_bad()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = (int64_t *)malloc(50*sizeof(int64_t));\n    if (data == NULL) {exit(-1);}\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_63b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    badSource(data);\n    {\n        char source[100];\n        char dest[100] = \"\";\n        memset(source, 'A', 100-1);\n        source[100-1] = '\\0';\n        if (data < 100)\n        {\n            /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\n             * the sign conversion could result in a very large number */\n            strncpy(dest, source, data);\n            dest[data] = '\\0'; /* strncpy() does not always NULL terminate */\n        }\n        printLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__short_rand_postinc_13_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_45_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_03_bad()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(5==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_fscanf_add_66_bad()\n{\n    int64_t data;\n    int64_t dataArray[5];\n    data = 0LL;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%\" SCNd64, &data);\n    /* put data in array */\n    dataArray[2] = data;\n    CWE190_Integer_Overflow__int64_t_fscanf_add_66b_badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_rand_multiply_34_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_int_static_64_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE176_Improper_Handling_of_Unicode_Encoding__w32_53_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_char_alloca_65_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_wchar_t_connect_socket_14_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_long_static_01_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE398_Poor_Code_Quality__empty_for_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: An empty for statement has no effect */\n    {\n        int i;\n        for (i = 0; i < 10; i++)\n        {\n        }\n    }\n    printLine(\"Hello from bad()\");\n}\n\n#endif /* OMITBAD */", "target_text": "CWE398 - Poor Code Quality"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    /* Initialize data */\n    data = NULL;\n    data = new long;\n    /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */\n    delete data;\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE415 - Double Free"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fgets_modulo_17_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__wchar_t_realloc_07_good()\n{\n    goodB2G1();\n    goodB2G2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    badSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__malloc_char_loop_01_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    /* define a function pointer */\n    void (*funcPtr) (twoIntsStruct *) = badSink;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        static twoIntsStruct dataBuffer;\n        dataBuffer.intOne = 1;\n        dataBuffer.intTwo = 1;\n        data = &dataBuffer;\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE416_Use_After_Free__malloc_free_int_09_bad()\n{\n    int * data;\n    /* Initialize data */\n    data = NULL;\n    if(GLOBAL_CONST_TRUE)\n    {\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        /* POTENTIAL FLAW: Free data in the source - the bad sink attempts to use data */\n        free(data);\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Use of data that may have been freed */\n        printIntLine(data[0]);\n        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE416 - Use After Free"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_10_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE617_Reachable_Assertion__rand_07_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_rand_postinc_31_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE457_Use_of_Uninitialized_Variable__struct_13_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    TwoIntsClass * *dataPtr1 = &data;\n    TwoIntsClass * *dataPtr2 = &data;\n    /* Initialize data*/\n    data = NULL;\n    {\n        TwoIntsClass * data = *dataPtr1;\n        /* POTENTIAL FLAW: Allocate memory with a function that requires delete to free the memory */\n        data = new TwoIntsClass;\n        *dataPtr1 = data;\n    }\n    {\n        TwoIntsClass * data = *dataPtr2;\n        /* POTENTIAL FLAW: Deallocate memory using delete [] - the source memory allocation function may\n         * require a call to delete to deallocate the memory */\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_rand_postinc_45_bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE190_Integer_Overflow__int_rand_postinc_45_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__char_rand_add_11_bad()\n{\n    char data;\n    data = ' ';\n    if(globalReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Use a random value */\n        data = (char)RAND32();\n    }\n    if(globalReturnsTrue())\n    {\n        {\n            /* POTENTIAL FLAW: Adding 1 to data could cause an overflow */\n            char result = data + 1;\n            printHexCharLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_system_08_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_15_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        int fileDesc;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int64_t_min_multiply_65_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE427_Uncontrolled_Search_Path_Element__wchar_t_environment_04_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[250] = L\"PATH=\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                wcsncat(data+dataLen, environment, 250-dataLen-1);\n            }\n        }\n    }\n    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */\n    PUTENV(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE427 - Uncontrolled Search Path Element"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_17_bad()\n{\n    int i,j;\n    unsigned int data;\n    data = 0;\n    for(i = 0; i < 1; i++)\n    {\n        /* POTENTIAL FLAW: Use a random value */\n        data = (unsigned int)RAND32();\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n            ++data;\n            unsigned int result = data;\n            printUnsignedLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_05_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_rand_postinc_31_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_file_printf_67_bad()\n{\n    wchar_t * data;\n    CWE134_Uncontrolled_Format_String__wchar_t_file_printf_67_structType myStruct;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    myStruct.structFirst = data;\n    CWE134_Uncontrolled_Format_String__wchar_t_file_printf_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_02_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__malloc_char_memmove_44_bad()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = badSink;\n    data = NULL;\n    {\n        char * dataBuffer = (char *)malloc(100*sizeof(char));\n        if (dataBuffer == NULL) {exit(-1);}\n        memset(dataBuffer, 'A', 100-1);\n        dataBuffer[100-1] = '\\0';\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE457_Use_of_Uninitialized_Variable__double_array_declare_partial_init_14_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__wchar_t_declare_cpy_04_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            ifstream inputFile;\n            /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n            inputFile.open((char *)data);\n            inputFile.close();\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__wchar_t_fprintf_09_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__wchar_t_declare_loop_68_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    badSource(data);\n    /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n    if (SYSTEM(data) != 0)\n    {\n        printLine(\"command execution failed!\");\n        exit(1);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    badSink(dataList);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE427_Uncontrolled_Search_Path_Element__char_file_51_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__struct_twoIntsStruct_realloc_18_bad()\n{\n    struct _twoIntsStruct * data;\n    data = NULL;\n    goto source;\nsource:\n    /* POTENTIAL FLAW: Allocate memory on the heap */\n    data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));\n    if (data == NULL) {exit(-1);}\n    /* Initialize and make use of data */\n    data[0].intOne = 0;\n    data[0].intTwo = 0;\n    printStructLine((twoIntsStruct *)&data[0]);\n    goto sink;\nsink:\n    /* POTENTIAL FLAW: No deallocation */\n    ; /* empty statement needed for some flow variants */\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    CWE369_Divide_by_Zero__int_zero_modulo_84_bad * badObject = new CWE369_Divide_by_Zero__int_zero_modulo_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE758_Undefined_Behavior__int64_t_alloca_use_05_bad()\n{\n    if(staticTrue)\n    {\n        {\n            int64_t * pointer = (int64_t *)ALLOCA(sizeof(int64_t));\n            int64_t data = *pointer; /* FLAW: the value pointed to by pointer is undefined */\n            printLongLongLine(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE758 - Undefined Behavior"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE675_Duplicate_Operations_on_Resource__open_52_bad()\n{\n    int data;\n    data = -1; /* Initialize data */\n    data = OPEN(\"BadSource_open.txt\", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n    /* POTENTIAL FLAW: Close the file in the source */\n    CLOSE(data);\n    CWE675_Duplicate_Operations_on_Resource__open_52b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE675 - Duplicate Operations on Resource"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__wchar_t_declare_memcpy_09_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_console_w32_vsnprintf_45_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = wcslen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgetws() */\n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    CWE134_Uncontrolled_Format_String__wchar_t_console_w32_vsnprintf_45_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE680 - Integer Overflow to Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_45_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE563_Unused_Variable__unused_value_int64_t_08_bad()\n{\n    int64_t data;\n    if(staticReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Initialize, but do not use data */\n        data = 5LL;\n    }\n    if(staticReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Possibly over-write the initial value of data before using it */\n        data = 10LL;\n        printLongLongLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE563 - Unused Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_66_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__connect_socket_sleep_16_bad()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    while(1)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET connectSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read count using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                count = atoi(inputBuffer);\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        break;\n    }\n    while(1)\n    {\n        /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */\n        SLEEP(count);\n        printLine(\"Sleep time possibly too long\");\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_max_add_54_bad()\n{\n    unsigned int data;\n    data = 0;\n    /* POTENTIAL FLAW: Use the maximum size of the data type */\n    data = UINT_MAX;\n    CWE190_Integer_Overflow__unsigned_int_max_add_54b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int * data;\n    map<int, int *> dataMap;\n    data = NULL;\n    /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = (int *)malloc(50*sizeof(int));\n    if (data == NULL) {exit(-1);}\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_18_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    unionType myUnion;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            HANDLE hFile;\n            /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n            hFile = CreateFileA(data,\n                                (GENERIC_WRITE|GENERIC_READ),\n                                0,\n                                NULL,\n                                OPEN_ALWAYS,\n                                FILE_ATTRIBUTE_NORMAL,\n                                NULL);\n            if (hFile != INVALID_HANDLE_VALUE)\n            {\n                CloseHandle(hFile);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__short_fscanf_multiply_15_bad()\n{\n    short data;\n    data = 0;\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Use a value input from the console */\n        fscanf (stdin, \"%hd\", &data);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        if(data < 0) /* ensure we won't have an overflow */\n        {\n            /* POTENTIAL FLAW: if (data * 2) < SHRT_MIN, this will underflow */\n            short result = data * 2;\n            printIntLine(result);\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));\n    if (data == NULL) {exit(-1);}\n    badGlobal = 1; /* true */\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_01_bad()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE617_Reachable_Assertion__fixed_17_bad()\n{\n    int i;\n    int data;\n    /* Initialize data */\n    data = -1;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Use a value less than the assert value */\n        data = ASSERT_VALUE-1;\n    }\n    /* POTENTIAL FLAW: this assertion could trigger if n <= ASSERT_VALUE */\n    assert(data > ASSERT_VALUE);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE617 - Reachable Assertion"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__wchar_t_fprintf_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Do not check the return value */\n        fwprintf(stdout, L\"%s\\n\", L\"string\");\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE252 - Unchecked Return Value"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    {\n        char * data = dataRef;\n        badVaSink(data, data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        /* Restore NUL terminator if fgetws fails */\n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE377_Insecure_Temporary_File__wchar_t_mktemp_12_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__fscanf_for_loop_01_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE468_Incorrect_Pointer_Scaling__int_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            int *intPointer = intArray;\n            /* get intArray[2] */\n            /* FLAW: included *sizeof(int) which is unnecessary since pointer arithmetic is automatically scaled */\n            int toPrint = *(intPointer+(2*sizeof(int)));\n            printIntLine(toPrint);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE468 - Incorrect Pointer Scaling"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_18_bad()\n{\n    wchar_t * data;\n    data = NULL;\n    goto source;\nsource:\n    /* FLAW: Did not leave space for a null terminator */\n    data = (wchar_t *)malloc(10*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Set data to a value that will cause an integer overflow in the call to new[] in the sink */\n        data = INT_MAX / 2 + 2; /* 1073741825 */\n        /* NOTE: This value will cause the sink to only allocate 4 bytes of memory, however\n         * the for loop will attempt to access indices 0-1073741824 */\n    }\n    {\n        size_t dataBytes,i;\n        int *intPointer;\n        /* POTENTIAL FLAW: dataBytes may overflow to a small value */\n        dataBytes = data * sizeof(int); /* sizeof array in bytes */\n        intPointer = (int*)new char[dataBytes];\n        for (i = 0; i < (size_t)data; i++)\n        {\n            intPointer[i] = 0; /* may write beyond limit of intPointer if integer overflow occured above */\n        }\n        printIntLine(intPointer[0]);\n        delete [] intPointer;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE680 - Integer Overflow to Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));\n    if (data == NULL) {exit(-1);}\n    {\n        twoIntsStruct * dataCopy = data;\n        twoIntsStruct * data = dataCopy;\n        /* POTENTIAL FLAW: Deallocate memory using delete [] - the source memory allocation function may\n         * require a call to free() to deallocate the memory */\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_environment_popen_06_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__negative_memcpy_08_bad()\n{\n    short data;\n    /* Initialize data */\n    data = 0;\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Use a negative number */\n        data = -1;\n    }\n    {\n        char source[100];\n        char dest[100] = \"\";\n        memset(source, 'A', 100-1);\n        source[100-1] = '\\0';\n        if (data < 100)\n        {\n            /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\n             * the sign extension could result in a very large number */\n            memcpy(dest, source, data);\n            dest[data] = '\\0'; /* NULL terminate */\n        }\n        printLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE775_Missing_Release_of_File_Descriptor_or_Handle__w32CreateFile_no_close_53_bad()\n{\n    HANDLE data;\n    /* Initialize data */\n    data = INVALID_HANDLE_VALUE;\n    /* POTENTIAL FLAW: Open a file without closing it */\n    data = CreateFile(\"BadSource_w32CreateFile.txt\",\n                      (GENERIC_WRITE|GENERIC_READ),\n                      0,\n                      NULL,\n                      OPEN_ALWAYS,\n                      FILE_ATTRIBUTE_NORMAL,\n                      NULL);\n    CWE775_Missing_Release_of_File_Descriptor_or_Handle__w32CreateFile_no_close_53b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE775 - Missing Release of File Descriptor or Handle After Effective Lifetime"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__malloc_char_memmove_12_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    unsigned int data;\n    data = 0;\n    badSource(data);\n    {\n        /* POTENTIAL FLAW: Subtracting 1 from data could cause an underflow */\n        unsigned int result = data - 1;\n        printUnsignedLine(result);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_04_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        /* Restore NUL terminator if fgetws fails */\n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__malloc_char_loop_01_bad()\n{\n    char * data;\n    data = NULL;\n    {\n        char * dataBuffer = (char *)malloc(100*sizeof(char));\n        if (dataBuffer == NULL) {exit(-1);}\n        memset(dataBuffer, 'A', 100-1);\n        dataBuffer[100-1] = '\\0';\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n         * returned by malloc() so can't safely call free() on it */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__float_rand_67_bad()\n{\n    float data;\n    CWE369_Divide_by_Zero__float_rand_67_structType myStruct;\n    /* Initialize data */\n    data = 0.0F;\n    /* POTENTIAL FLAW: Use a random number that could possibly equal zero */\n    data = (float)RAND32();\n    myStruct.structFirst = data;\n    CWE369_Divide_by_Zero__float_rand_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE284_Improper_Access_Control__w32_char_CreateWindowStation_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            HWINSTA hWinStation;\n            char * wStationName = \"WindowsStationExample\";\n            /* FLAW: Call CreateWindowStationA() with GENERIC_ALL as the 3rd parameter */\n            hWinStation = CreateWindowStationA(\n                              wStationName,\n                              0,\n                              GENERIC_ALL,\n                              NULL);\n            if (hWinStation == NULL)\n            {\n                printLine(\"Windows station could not be created\");\n            }\n            else\n            {\n                printLine(\"Windows Station created successfully\");\n                CloseWindowStation(hWinStation);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE284 - Improper Access Control"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncat_51_bad()\n{\n    wchar_t * data;\n    data = (wchar_t *)malloc(100*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncat_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_07_bad()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(staticFive==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE534_Info_Exposure_Debug_Log__w32_wchar_t_09_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    /* Initialize data*/\n    data = NULL;\n    if(globalTrue)\n    {\n        data = NULL;\n        /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n        data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n    }\n    if(globalTrue)\n    {\n        /* POTENTIAL FLAW: Deallocate memory using delete [] - the source memory allocation function may\n         * require a call to free() to deallocate the memory */\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__wchar_t_scanf_16_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_rand_add_61_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_console_63_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_listen_socket_sub_66_bad()\n{\n    int data;\n    int dataArray[5];\n    /* Initialize data */\n    data = 0;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE191_Integer_Underflow__int_listen_socket_sub_66b_badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE606_Unchecked_Loop_Condition__wchar_t_console_02_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__malloc_wchar_t_loop_53_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t data;\n    data = 0LL;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%\" SCNd64, &data);\n    CWE190_Integer_Overflow__int64_t_fscanf_add_82_base* baseObject = new CWE190_Integer_Overflow__int64_t_fscanf_add_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_05_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wexecv - specify the path where the command is located */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        EXECV(COMMAND_INT_PATH, args);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    /* Initialize data */\n    data = NULL;\n    if(staticFive==5)\n    {\n        data = new long[100];\n        /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */\n        delete [] data;\n    }\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Possibly deleting memory twice */\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE415 - Double Free"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = (wchar_t *)malloc(50*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_82_base* baseObject = new CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_12_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));\n    if (data == NULL) {exit(-1);}\n    badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_file_fprintf_12_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        /* Restore NUL terminator if fgetws fails */\n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    else\n    {\n        /* FIX: Use a fixed string that does not contain a format specifier */\n        wcscpy(data, L\"fixedstringtest\");\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n        fwprintf(stdout, data);\n    }\n    else\n    {\n        /* FIX: Specify the format disallowing a format string vulnerability */\n        fwprintf(stdout, L\"%s\\n\", data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    structType myStruct;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    myStruct.structFirst = data;\n    badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__char_alloca_cpy_17_bad()\n{\n    int i;\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    {\n        char dest[100*2];\n        memset(dest, 'C', 100*2-1); /* fill with 'C's */\n        dest[100*2-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */\n        strcpy(dest, data);\n        printLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__char_sscanf_15_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    if(5==5)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = strlen(data);\n            /* if there is room in data, read into it from the console */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgets() */\n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        FILE *pFile = NULL;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        pFile = FOPEN(data, \"wb+\");\n        if (pFile != NULL)\n        {\n            fclose(pFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_04_bad()\n{\n    char * data;\n    data = (char *)malloc(100*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    data[0] = '\\0';\n    /* POTENTIAL FLAW: Initialize data to be a fixed string that contains the search character in the sinks */\n    strcpy(data, BAD_SOURCE_FIXED_STRING);\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: We are incrementing the pointer in the loop - this will cause us to free the\n         * memory block not at the start of the buffer */\n        for (; *data != '\\0'; data++)\n        {\n            if (*data == SEARCH_CHAR)\n            {\n                printLine(\"We have a match!\");\n                break;\n            }\n        }\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE761 - Free Pointer not at Start of Buffer"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__negative_malloc_09_bad()\n{\n    short data;\n    /* Initialize data */\n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Use a negative number */\n        data = -1;\n    }\n    /* Assume we want to allocate a relatively small buffer */\n    if (data < 100)\n    {\n        /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,\n         * the conversion will cause malloc() to allocate a very large amount of data or fail */\n        char * dataBuffer = (char *)malloc(data);\n        if (dataBuffer == NULL) {exit(-1);}\n        /* Do something with dataBuffer */\n        memset(dataBuffer, 'A', data-1);\n        dataBuffer[data-1] = '\\0';\n        printLine(dataBuffer);\n        free(dataBuffer);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__char_fscanf_add_04_bad()\n{\n    char data;\n    data = ' ';\n    if(STATIC_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Use a value input from the console */\n        fscanf (stdin, \"%c\", &data);\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* POTENTIAL FLAW: Adding 1 to data could cause an overflow */\n            char result = data + 1;\n            printHexCharLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__rand_sleep_64_bad()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    /* POTENTIAL FLAW: Set count to a random value */\n    count = RAND32();\n    CWE400_Resource_Exhaustion__rand_sleep_64b_badSink(&count);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        TwoIntsClass * dataBuffer = (TwoIntsClass *)ALLOCA(sizeof(TwoIntsClass));\n        dataBuffer->intOne = 2;\n        dataBuffer->intTwo = 2;\n        data = dataBuffer;\n    }\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_52_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_52b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    badSource(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        strncpy(data, source, 100-1);\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n         * returned by new [] so can't safely call delete [] on it */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__CWE839_fgets_12_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_fgets_03_bad()\n{\n    if(5==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() and other variants */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printLine(\"Please enter a string: \");\n            /* FLAW: Incorrectly check the return value: if this function failed it will return NULL,\n             * but we are checking to see if the return value is less than 0. */\n            if (fgetws(data, 100, stdin) < 0)\n            {\n                printLine(\"fgetws failed!\");\n                exit(1);\n            }\n            printWLine(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE253 - Incorrect Check of Return Value"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE416_Use_After_Free__malloc_free_int_13_bad()\n{\n    int * data;\n    /* Initialize data */\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        {\n            size_t i;\n            for(i = 0; i < 100; i++)\n            {\n                data[i] = 5;\n            }\n        }\n        /* POTENTIAL FLAW: Free data in the source - the bad sink attempts to use data */\n        free(data);\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Use of data that may have been freed */\n        printIntLine(data[0]);\n        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE416 - Use After Free"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__short_fscanf_square_68_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_08_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE606_Unchecked_Loop_Condition__wchar_t_console_02_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = wcslen(data);\n            /* if there is room in data, read into it from the console */\n            if (100-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgetws() */\n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    if(1)\n    {\n        {\n            int i, n, intVariable;\n            if (swscanf(data, L\"%d\", &n) == 1)\n            {\n                /* POTENTIAL FLAW: user-supplied value 'n' could lead to very large loop iteration */\n                intVariable = 0;\n                for (i = 0; i < n; i++)\n                {\n                    /* INCIDENTAL: CWE 561: Dead Code - non-avoidable if n <= 0 */\n                    intVariable++; /* avoid a dead/empty code block issue */\n                }\n                printIntLine(intVariable);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE606 - Unchecked Input For Loop Condition"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE511_Logic_Time_Bomb__rand_17_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE427_Uncontrolled_Search_Path_Element__wchar_t_file_01_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[250] = L\"PATH=\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (250-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgetws(data+dataLen, (int)(250-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    /* POTENTIAL FLAW: Set a new environment variable with a path that is possibly insecure */\n    PUTENV(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE427 - Uncontrolled Search Path Element"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE114_Process_Control__w32_char_file_16_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    while(1)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n        break;\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE114 - Process Control"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE478_Missing_Default_Case_in_Switch__basic_07_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__CWE170_char_strncpy_09_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__short_fscanf_multiply_15_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE272_Least_Privilege_Violation__w32_wchar_t_RegCreateKey_11_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE325_Missing_Required_Cryptographic_Step__w32_CryptEncrypt_03_bad()\n{\n    if(5==5)\n    {\n        {\n            BYTE payload[100];\n            DWORD payloadLen = strlen(PAYLOAD);\n            HCRYPTPROV hCryptProv = (HCRYPTPROV)NULL;\n            HCRYPTHASH hHash = (HCRYPTHASH)NULL;\n            HCRYPTKEY hKey = (HCRYPTKEY)NULL;\n            char hashData[100] = HASH_INPUT;\n            do\n            {\n                /* Copy plaintext into payload buffer */\n                memcpy(payload, PAYLOAD, payloadLen);\n                /* Aquire a Context */\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                /* Create hash handle */\n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                /* Hash the input string */\n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                /* Derive an AES key from the hash */\n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                /* FLAW: Missing required step (CryptEncrypt) does not encrypt the payload */\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            /* Do something with the encrypted data */\n            printBytesLine(payload, payloadLen);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE325 - Missing Required Cryptographic Step"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_rand_postinc_68_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE416_Use_After_Free__malloc_free_struct_06_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_console_vfprintf_34_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    data = NULL; /* Initialize data */\n    if(5==5)\n    {\n        {\n            /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n            char buffer[sizeof(long)];\n            long * dataBuffer = new(buffer) long;\n            *dataBuffer = 5L;\n            data = dataBuffer;\n        }\n    }\n    printLongLine(*data);\n    /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */\n    delete data;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_07_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(staticFive==5)\n    {\n        badVaSinkB(data, data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE416_Use_After_Free__malloc_free_int_13_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_63_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    CWE78_OS_Command_Injection__char_environment_w32_spawnv_82_base* baseObject = new CWE78_OS_Command_Injection__char_environment_w32_spawnv_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE197_Numeric_Truncation_Error__short_rand_06_bad()\n{\n    short data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Use a random number */\n        data = (short)RAND32();\n    }\n    {\n        /* POTENTIAL FLAW: Convert data to a char, possibly causing a truncation error */\n        char charData = (char)data;\n        printHexCharLine(charData);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE197 - Numeric Truncation Error"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\n// safe_example.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void) {\n    /* Read a user-provided string safely into a fixed-size buffer. */\n    char name[64];\n    printf(\"Enter your name (max 63 chars): \");\n    if (fgets(name, sizeof(name), stdin) == NULL) {\n        fprintf(stderr, \"Input error\\n\");\n        return 1;\n    }\n    /* Remove trailing newline, if present */\n    name[strcspn(name, \"\\n\")] = '\\0';\n\n    /* Build a greeting using snprintf (prevents buffer overflow) */\n    char greeting[128];\n    if (snprintf(greeting, sizeof(greeting), \"Hello, %s!\", name) >= (int)sizeof(greeting)) {\n        fprintf(stderr, \"Greeting truncated\\n\");\n    }\n\n    puts(greeting);\n\n    /* Example: allocate memory for a copy of the greeting */\n    size_t len = strlen(greeting) + 1;\n    char *copy = malloc(len);\n    if (copy == NULL) {\n        perror(\"malloc\");\n        return 1;\n    }\n    /* Use memcpy/strncpy carefully (here we know sizes) */\n    memcpy(copy, greeting, len); /* safe because we allocated len bytes */\n\n    printf(\"Copied greeting: %s\\n\", copy);\n\n    /* Clean up */\n    free(copy);\n    return 0;\n}\n", "target_text": "SAFE - No vulnerability detected", "source": "user_feedback", "feedback_id": "c2ea7fcc703b", "feedback_type": "false_positive"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    badSink(dataList);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_loop_02_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    /* Initialize data*/\n    data = NULL;\n    goto source;\nsource:\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (int64_t *)realloc(data, 100*sizeof(int64_t));\n    if (data == NULL) {exit(-1);}\n    goto sink;\nsink:\n    /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may\n     * require a call to free() to deallocate the memory */\n    delete data;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__int_malloc_13_bad()\n{\n    int * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Allocate memory on the heap */\n        data = (int *)malloc(100*sizeof(int));\n        if (data == NULL) {exit(-1);}\n        /* Initialize and make use of data */\n        data[0] = 5;\n        printIntLine(data[0]);\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: No deallocation */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (wchar_t *)calloc(100, sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    badStatic = 1; /* true */\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    /* Initialize data */\n    data = NULL;\n    data = new TwoIntsClass;\n    /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */\n    delete data;\n    const CWE415_Double_Free__new_delete_class_81_base& o = CWE415_Double_Free__new_delete_class_81_bad();\n    o.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE415 - Double Free"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_connect_socket_predec_44_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_listen_socket_divide_61_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    data = CWE369_Divide_by_Zero__int_listen_socket_divide_61b_badSource(data);\n    /* POTENTIAL FLAW: Possibly divide by zero */\n    printIntLine(100 / data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    badGlobal = 1; /* true */\n    data = badSource(data);\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n    ;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_32_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE253_Incorrect_Check_of_Function_Return_Value__wchar_t_putchar_18_bad()\n{\n    goto sink;\nsink:\n    /* FLAW: putwchar() might fail, in which case the return value will be WEOF (-1), but\n     * we are checking to see if the return value is 0 */\n    if (putwchar((wchar_t)L'A') == 0)\n    {\n        printLine(\"putwchar failed!\");\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE253 - Incorrect Check of Return Value"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE587_Assignment_of_Fixed_Address_to_Pointer__basic_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* FLAW: Assigning fixed address to pointer */\n            char *charPointer = (char*)0x400000;\n            printHexCharLine(*charPointer);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE587 - Assignment of Fixed Address to Pointer"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE226_Sensitive_Information_Uncleared_Before_Release__w32_wchar_t_declare_17_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__rand_sleep_14_bad()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    if(globalFive==5)\n    {\n        /* POTENTIAL FLAW: Set count to a random value */\n        count = RAND32();\n    }\n    if(globalFive==5)\n    {\n        /* POTENTIAL FLAW: Sleep function using count as the parameter with no validation */\n        SLEEP(count);\n        printLine(\"Sleep time possibly too long\");\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53_bad()\n{\n    size_t data;\n    /* Initialize data */\n    data = 0;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = rand();\n    CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE789 - Uncontrolled Memory Allocation"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE123_Write_What_Where_Condition__connect_socket_67_bad()\n{\n    badStruct data;\n    CWE123_Write_What_Where_Condition__connect_socket_67_structType myStruct;\n    linkedList head = { &head, &head };\n    /* This simulates a Microsoft-style linked list insertion */\n    data.list.next = head.next;\n    data.list.prev = head.prev;\n    head.next = &data.list;\n    head.prev = &data.list;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* FLAW: overwrite linked list pointers with data */\n            recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myStruct.structFirst = data;\n    CWE123_Write_What_Where_Condition__connect_socket_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE123 - Write-What-Where Condition"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_52_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__fscanf_strncpy_01_bad()\n{\n    short data;\n    /* Initialize data */\n    data = 0;\n    /* FLAW: Use a value input from the console using fscanf() */\n    fscanf (stdin, \"%hd\", &data);\n    {\n        char source[100];\n        char dest[100] = \"\";\n        memset(source, 'A', 100-1);\n        source[100-1] = '\\0';\n        if (data < 100)\n        {\n            /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\n             * the sign extension could result in a very large number */\n            strncpy(dest, source, data);\n            dest[data] = '\\0'; /* strncpy() does not always NULL terminate */\n        }\n        printLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_system_09_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__malloc_wchar_t_loop_42_bad()\n{\n    wchar_t * data;\n    data = NULL;\n    data = badSource(data);\n    {\n        size_t i, destLen;\n        wchar_t dest[100];\n        wmemset(dest, L'C', 100-1);\n        dest[100-1] = L'\\0'; /* null terminate */\n        destLen = wcslen(dest);\n        /* POTENTIAL FLAW: using length of the dest where data\n         * could be smaller than dest causing buffer overread */\n        for (i = 0; i < destLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[100-1] = L'\\0';\n        printWLine(dest);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Over-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_83_bad badObject(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_11_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* spawnv - specify the path where the command is located */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        int64_t dataBuffer[100];\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i] = 5LL;\n            }\n        }\n        data = dataBuffer;\n    }\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_17_bad()\n{\n    int i;\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* execvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        EXECVP(COMMAND_INT, args);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__char_alloca_memcpy_14_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = (wchar_t *)malloc(100*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    badSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE563_Unused_Variable__unused_uninit_variable_long_21_bad()\n{\n    long data;\n    /* POTENTIAL FLAW: Do not initialize or use data */\n    ; /* empty statement needed for some flow variants */\n    badStatic = 1; /* true */\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE563 - Unused Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE90_LDAP_Injection__w32_wchar_t_environment_41_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[256] = L\"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, 256-dataLen-1);\n        }\n    }\n    CWE90_LDAP_Injection__w32_wchar_t_environment_41_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE90 - LDAP Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_65_bad()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_65b_badSink;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE415_Double_Free__malloc_free_struct_42_bad()\n{\n    twoIntsStruct * data;\n    /* Initialize data */\n    data = NULL;\n    data = badSource(data);\n    /* POTENTIAL FLAW: Possibly freeing memory twice */\n    free(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE415 - Double Free"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    /* FLAW: Set data pointer to before the allocated memory buffer */\n    data = dataBuffer - 8;\n    const CWE127_Buffer_Underread__char_alloca_memcpy_81_base& baseObject = CWE127_Buffer_Underread__char_alloca_memcpy_81_bad();\n    baseObject.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32_execvp_04_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65_bad()\n{\n    int data;\n    /* define a function pointer */\n    void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65b_badSink;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    vector<long *> dataVector;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        long * dataBuffer = (long *)ALLOCA(100*sizeof(long));\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i] = 5L;\n            }\n        }\n        data = dataBuffer;\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    badSink(dataVector);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__connect_socket_sleep_16_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    /* Initialize data */\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        data = new wchar_t;\n        *data = L'A';\n        /* POTENTIAL FLAW: Delete data in the source - the bad sink attempts to use data */\n        delete data;\n    }\n    else\n    {\n        data = new wchar_t;\n        *data = L'A';\n        /* FIX: Do not delete data in the source */\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        /* POTENTIAL FLAW: Use of data that may have been deleted */\n        printWcharLine(*data);\n        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not deleted */\n    }\n    else\n    {\n        /* FIX: Don't use data that may have been deleted already */\n        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not deleted */\n        /* do nothing */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE416 - Use After Free"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    badSource(data);\n    /* wspawnl - specify the path where the command is located */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_file_fprintf_02_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        /* Restore NUL terminator if fgetws fails */\n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    if(1)\n    {\n        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n        fwprintf(stdout, data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE617_Reachable_Assertion__fgets_68_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_83_bad badObject(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char * &dataRef = data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    {\n        char * data = dataRef;\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__wchar_t_declare_loop_15_bad()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    wmemset(dataBadBuffer, L'A', 50-1); /* fill with 'A's */\n    dataBadBuffer[50-1] = L'\\0'; /* null terminate */\n    wmemset(dataGoodBuffer, L'A', 100-1); /* fill with 'A's */\n    dataGoodBuffer[100-1] = L'\\0'; /* null terminate */\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set data pointer to a small buffer */\n        data = dataBadBuffer;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        size_t i, destLen;\n        wchar_t dest[100];\n        wmemset(dest, L'C', 100-1);\n        dest[100-1] = L'\\0'; /* null terminate */\n        destLen = wcslen(dest);\n        /* POTENTIAL FLAW: using length of the dest where data\n         * could be smaller than dest causing buffer overread */\n        for (i = 0; i < destLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[100-1] = L'\\0';\n        printWLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Over-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__char_malloc_32_bad()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    data = NULL;\n    {\n        char * data = *dataPtr1;\n        /* POTENTIAL FLAW: Allocate memory on the heap */\n        data = (char *)malloc(100*sizeof(char));\n        if (data == NULL) {exit(-1);}\n        /* Initialize and make use of data */\n        strcpy(data, \"A String\");\n        printLine(data);\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        /* POTENTIAL FLAW: No deallocation */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    badSource(data);\n    if(data < 0) /* ensure we won't have an overflow */\n    {\n        /* POTENTIAL FLAW: if (data * 2) < INT_MIN, this will underflow */\n        int result = data * 2;\n        printIntLine(result);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE390_Error_Without_Action__fgets_wchar_t_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgetws() */\n            wchar_t dataBuffer[100] = L\"\";\n            wchar_t * data = dataBuffer;\n            printWLine(L\"Please enter a string: \");\n            /* FLAW: check the return value, but do nothing if there is an error */\n            if (fgetws(data, 100, stdin) == NULL)\n            {\n                /* do nothing */\n            }\n            printWLine(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE390 - Detection of Error Condition Without Action"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_console_w32spawnl_14_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = strlen(data);\n            /* if there is room in data, read into it from the console */\n            if (100-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgets() */\n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    /* spawnl - specify the path where the command is located */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticTrue)\n    {\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n    }\n    {\n        size_t dataBytes,i;\n        int *intPointer;\n        /* POTENTIAL FLAW: dataBytes may overflow to a small value */\n        dataBytes = data * sizeof(int); /* sizeof array in bytes */\n        intPointer = (int*)new char[dataBytes];\n        for (i = 0; i < (size_t)data; i++)\n        {\n            intPointer[i] = 0; /* may write beyond limit of intPointer if integer overflow occured above */\n        }\n        printIntLine(intPointer[0]);\n        delete [] intPointer;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE680 - Integer Overflow to Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    badSink(dataVector);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE606 - Unchecked Input For Loop Condition"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_file_fprintf_02_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__wchar_t_declare_loop_11_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_44_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[250] = \"PATH=\";\n    data = dataBuffer;\n    CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_84_bad * badObject = new CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE427 - Uncontrolled Search Path Element"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    CWE78_OS_Command_Injection__char_listen_socket_w32_execv_84_bad * badObject = new CWE78_OS_Command_Injection__char_listen_socket_w32_execv_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    FILE * data;\n    /* Initialize data */\n    data = NULL;\n    badSource(data);\n    if (data != NULL)\n    {\n        /* FLAW: Attempt to close the file using CloseHandle() instead of fclose() */\n        CloseHandle((HANDLE)data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE404 - Improper Resource Shutdown or Release"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    long * dataArray[5];\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        static long dataBuffer;\n        dataBuffer = 5L;\n        data = &dataBuffer;\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__connect_socket_for_loop_64_bad()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read count using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            count = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE400_Resource_Exhaustion__connect_socket_for_loop_64b_badSink(&count);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (TwoIntsClass *)malloc(100*sizeof(TwoIntsClass));\n    if (data == NULL) {exit(-1);}\n    CWE762_Mismatched_Memory_Management_Routines__delete_array_class_malloc_82_base* baseObject = new CWE762_Mismatched_Memory_Management_Routines__delete_array_class_malloc_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        char buffer[sizeof(twoIntsStruct)];\n        twoIntsStruct * dataBuffer = new(buffer) twoIntsStruct;\n        dataBuffer->intOne = 1;\n        dataBuffer->intTwo = 1;\n        data = dataBuffer;\n    }\n    badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (wchar_t *)malloc(100*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_rand_multiply_15_bad()\n{\n    int64_t data;\n    data = 0LL;\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Use a random value */\n        data = (int64_t)RAND64();\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        if(data > 0) /* ensure we won't have an underflow */\n        {\n            /* POTENTIAL FLAW: if (data*2) > LLONG_MAX, this will overflow */\n            int64_t result = data * 2;\n            printLongLongLine(result);\n        }\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_06_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_82_base* baseObject = new CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__CWE129_listen_socket_31_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_06_bad()\n{\n    char * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = (char *)malloc(10*sizeof(char));\n        if (data == NULL) {exit(-1);}\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * data = dataRef;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strncpy(data, source, strlen(source) + 1);\n            printLine(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE773_Missing_Reference_to_Active_File_Descriptor_or_Handle__fopen_31_bad()\n{\n    FILE * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Create a file handle using fopen() that may not be closed properly */\n    data = fopen(\"BadSource_fopen.txt\", \"w+\");\n    {\n        FILE * dataCopy = data;\n        FILE * data = dataCopy;\n        /* FLAW: Point data to another file handle without closing the handle from the source */\n        data = fopen(\"BadSink_fopen.txt\", \"w+\");\n        /* avoid incidental for not closing the file handle */\n        if (data != NULL)\n        {\n            fclose(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE773 - Missing Reference to Active File Descriptor or Handle"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    short data;\n    short &dataRef = data;\n    /* Initialize data */\n    data = 0;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* FLAW: Use a value input from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to short */\n            data = (short)atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    {\n        short data = dataRef;\n        {\n            char source[100];\n            char dest[100] = \"\";\n            memset(source, 'A', 100-1);\n            source[100-1] = '\\0';\n            if (data < 100)\n            {\n                /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\n                 * the sign extension could result in a very large number */\n                strncpy(dest, source, data);\n                dest[data] = '\\0'; /* strncpy() does not always NULL terminate */\n            }\n            printLine(dest);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new wchar_t[10];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE457_Use_of_Uninitialized_Variable__struct_array_declare_partial_init_02_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__twoIntsStruct_malloc_13_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_10_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalTrue)\n    {\n        badVaSinkB(data, data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_fgets_preinc_52_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    TwoIntsClass * dataArray[5];\n    data = NULL; /* Initialize data */\n    {\n        /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n        TwoIntsClass dataBuffer[100];\n        {\n            size_t i;\n            for (i = 0; i < 100; i++)\n            {\n                dataBuffer[i].intOne = 1;\n                dataBuffer[i].intTwo = 1;\n            }\n        }\n        data = dataBuffer;\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_14_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        /* POTENTIAL FLAW: Convert data to a char, possibly causing a truncation error */\n        char charData = (char)data;\n        printHexCharLine(charData);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE197 - Numeric Truncation Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_09_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__CWE839_rand_04_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to access a negative index of the array\n            * This code does not check to see if the array index is negative */\n            if (data < 10)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__CWE170_char_strncpy_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char data[150], dest[100];\n            /* Initialize data */\n            memset(data, 'A', 149);\n            data[149] = '\\0';\n            /* strncpy() does not null terminate if the string in the src buffer is larger than\n             * the number of characters being copied to the dest buffer */\n            strncpy(dest, data, 99);\n            /* FLAW: do not explicitly null terminate dest after the use of strncpy() */\n            printLine(dest);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Overread"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_environment_w32spawnl_13_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_67_bad()\n{\n    int * data;\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_67_structType myStruct;\n    data = NULL;\n    /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = (int *)malloc(50*sizeof(int));\n    if (data == NULL) {exit(-1);}\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__malloc_char_cpy_63_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_environment_popen_05_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE367_TOC_TOU__stat_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        char filename[100] = \"\";\n        struct STAT statBuffer;\n        int fileDesc = -1;\n        if (fgets(filename, 100, stdin) == NULL)\n        {\n            printLine(\"fgets() failed\");\n            /* Restore NUL terminator if fgets fails */\n            filename[0] = '\\0';\n        }\n        if (strlen(filename) > 0)\n        {\n            filename[strlen(filename)-1] = '\\0'; /* remove newline */\n        }\n        /* FLAW: Open and write to the file after checking the status information */\n        if (STAT(filename, &statBuffer) == -1)\n        {\n            exit(1);\n        }\n        fileDesc  = OPEN(filename, O_RDWR);\n        if (fileDesc == -1)\n        {\n            exit(1);\n        }\n        if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1)\n        {\n            exit(1);\n        }\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE367 - Time-of-Check Time-Of-Use Race Condition"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE284_Improper_Access_Control__w32_char_CreateFile_06_bad()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            HANDLE hFile;\n            char * fileName = \"C:\\\\temp\\\\file.txt\";\n            /* FLAW: Call CreateFileA() with FILE_ALL_ACCESS as the 2nd parameter */\n            hFile = CreateFileA(\n                        fileName,\n                        FILE_ALL_ACCESS,\n                        FILE_SHARE_READ,\n                        NULL,\n                        CREATE_NEW,\n                        FILE_ATTRIBUTE_NORMAL,\n                        NULL);\n            if (hFile == INVALID_HANDLE_VALUE)\n            {\n                printLine(\"File could not be created\");\n            }\n            else\n            {\n                printLine(\"File created successfully\");\n                CloseHandle(hFile);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE284 - Improper Access Control"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_01_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_64_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_64b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_file_system_65_bad()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_file_system_65b_badSink;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    {\n        /* Read input from a file */\n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE476_NULL_Pointer_Dereference__int_68_bad()\n{\n    int * data;\n    /* POTENTIAL FLAW: Set data to NULL */\n    data = NULL;\n    CWE476_NULL_Pointer_Dereference__int_68_badData = data;\n    CWE476_NULL_Pointer_Dereference__int_68b_badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE476 - NULL Pointer Dereference"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int64_t_min_multiply_65_bad()\n{\n    int64_t data;\n    /* define a function pointer */\n    void (*funcPtr) (int64_t) = CWE191_Integer_Underflow__int64_t_min_multiply_65b_badSink;\n    data = 0LL;\n    /* POTENTIAL FLAW: Use the minimum size of the data type */\n    data = LLONG_MIN;\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_03_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__char_declare_loop_34_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE253_Incorrect_Check_of_Function_Return_Value__char_putchar_04_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE327_Use_Broken_Crypto__w32_RC5_06_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_file_vprintf_42_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    data = badSource(data);\n    badVaSink(data, data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE114_Process_Control__w32_wchar_t_file_54_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__char_fprintf_16_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_08_bad()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    /* Initialize data*/\n    data = NULL;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Allocate memory with a function that requires delete [] to free the memory */\n        data = new wchar_t[100];\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may\n         * require a call to delete [] to deallocate the memory */\n        delete data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_44_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_15_bad()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__wchar_t_realloc_63_bad()\n{\n    wchar_t * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory on the heap */\n    data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    /* Initialize and make use of data */\n    wcscpy(data, L\"A String\");\n    printWLine(data);\n    CWE401_Memory_Leak__wchar_t_realloc_63b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_16_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_53_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    list<int> dataList;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    badSink(dataList);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE197 - Numeric Truncation Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_listen_socket_divide_61_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fgets_divide_11_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_01_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory on the heap */\n    data = new twoIntsStruct;\n    /* Initialize and make use of data */\n    data->intOne = 0;\n    data->intTwo = 0;\n    printStructLine(data);\n    {\n        twoIntsStruct * dataCopy = data;\n        twoIntsStruct * data = dataCopy;\n        /* POTENTIAL FLAW: No deallocation */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__char_rand_square_42_bad()\n{\n    char data;\n    data = ' ';\n    data = badSource(data);\n    {\n        /* POTENTIAL FLAW: if (data*data) > CHAR_MAX, this will overflow */\n        char result = data * data;\n        printHexCharLine(result);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    data = reinterpret_cast<TwoIntsClass *>(ALLOCA(10*sizeof(TwoIntsClass)));\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Partially initialize data */\n        for(int i=0; i<(10/2); i++)\n        {\n            data[i].intOne = i;\n            data[i].intTwo = i;\n        }\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Use data without initializing it */\n        for(int i=0; i<10; i++)\n        {\n            printIntLine(data[i].intOne);\n            printIntLine(data[i].intTwo);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE457 - Use of Uninitialized Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_03_bad()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(5==5)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    /* Initialize data*/\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Allocate memory with a function that requires delete [] to free the memory */\n        data = new long[100];\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Deallocate memory using delete - the source memory allocation function may\n         * require a call to delete [] to deallocate the memory */\n        delete data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fgets_modulo_17_bad()\n{\n    int i,j;\n    int data;\n    /* Initialize data */\n    data = -1;\n    for(i = 0; i < 1; i++)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    for(j = 0; j < 1; j++)\n    {\n        /* POTENTIAL FLAW: Possibly divide by zero */\n        printIntLine(100 % data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__char_fscanf_square_66_bad()\n{\n    char data;\n    char dataArray[5];\n    data = ' ';\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%c\", &data);\n    /* put data in array */\n    dataArray[2] = data;\n    CWE190_Integer_Overflow__char_fscanf_square_66b_badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_09_bad()\n{\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            char string1[] = SOURCE_STRING;\n            char string2[] = SOURCE_STRING;\n            char * slashInString1;\n            size_t indexOfSlashInString1;\n            slashInString1 = strchr(string1, '/');\n            if (slashInString1 == NULL)\n            {\n                exit(1);\n            }\n            /* FLAW: subtracting the slash pointer from a completely different string, should be slashInString1 - string1 */\n            indexOfSlashInString1 = (size_t)(slashInString1 - string2);\n            /* print the index of where the slash was found */\n            printUnsignedLine(indexOfSlashInString1);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE469 - Use of Pointer Subtraction to Determine Size"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_13_bad()\n{\n    char * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = (char *)malloc(50*sizeof(char));\n        if (data == NULL) {exit(-1);}\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE223_Omission_of_Security_Relevant_Information__w32_15_bad()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        WSADATA wsaData;\n        BOOL wsaDataInit = FALSE;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        struct sockaddr_in service;\n        char username[USERNAME_SZ+1];\n        HANDLE pHandle;\n        do\n        {\n            if (0 != WSAStartup(MAKEWORD(2, 2), &wsaData))\n            {\n                break;\n            }\n            wsaDataInit = TRUE;\n            listenSocket = socket(PF_INET, SOCK_STREAM, 0);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(LISTEN_PORT);\n            if (SOCKET_ERROR == bind(listenSocket, (struct sockaddr*)&service, sizeof(service)))\n            {\n                break;\n            }\n            if (SOCKET_ERROR == listen(listenSocket, LISTEN_BACKLOG))\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))\n            {\n                break;\n            }\n            username[USERNAME_SZ] = '\\0';\n            /* INCIDENTAL CWE 188 - reliance on data memory layout\n             * recv and friends return \"number of bytes\" received\n             * fwrite wants \"the size of\".  ANSI/ISO allows the size of chars\n             * to be anything (32 bits, 9 bits, etc.) so technically you\n             * have to do conversion between these values\n            */\n            /* FLAW: username is not logged */\n            fprintf(stderr, \"Attempted login\\n\");\n            /* Establish the fact that the input is a username */\n            if (LogonUserA(\n                        username,\n                        DOMAIN,\n                        PASSWORD, /* INCIDENTAL CWE 259 - Hard-coded Password */\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n        while (0);\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE223 - Omission of Security Relevant Information"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__short_fscanf_multiply_54_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (char *)malloc(100*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    badGlobal = 1; /* true */\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_51_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_15_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__char_fscanf_add_04_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));\n    if (data == NULL) {exit(-1);}\n    const CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_81_base& baseObject = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_81_bad();\n    baseObject.action(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    /* Initialize data*/\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Allocate memory with a function that requires delete [] to free the memory */\n        data = new char[100];\n    }\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Deallocate memory using free() - the source memory allocation function may\n         * require a call to delete [] to deallocate the memory */\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE23_Relative_Path_Traversal__char_connect_socket_w32CreateFile_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_connect_socket_w32CreateFile_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_rand_add_61_bad()\n{\n    unsigned int data;\n    data = 0;\n    data = CWE190_Integer_Overflow__unsigned_int_rand_add_61b_badSource(data);\n    {\n        /* POTENTIAL FLAW: Adding 1 to data could cause an overflow */\n        unsigned int result = data + 1;\n        printUnsignedLine(result);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE464_Addition_of_Data_Structure_Sentinel__basic_41_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = badSink;\n    data = NULL;\n    /* FLAW: Use a small buffer */\n    data = new wchar_t[50];\n    wmemset(data, L'A', 50-1); /* fill with 'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Over-read"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fgets_divide_41_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_11_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_51_bad()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    size_t data;\n    /* Initialize data */\n    data = 0;\n    if(globalTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to unsigned int */\n                data = strtoul(inputBuffer, NULL, 0);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    if(globalTrue)\n    {\n        {\n            char * myString;\n            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough\n             * for the strcpy() function to not cause a buffer overflow */\n            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */\n            if (data > strlen(HELLO_STRING))\n            {\n                myString = new char[data];\n                /* Copy a small string into myString */\n                strcpy(myString, HELLO_STRING);\n                printLine(myString);\n                delete [] myString;\n            }\n            else\n            {\n                printLine(\"Input is less than the length of the source string\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE789 - Uncontrolled Memory Allocation"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_fscanf_sub_45_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    if(globalTrue)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    /* Initialize data*/\n    data = NULL;\n    data = badSource(data);\n    /* POTENTIAL FLAW: Deallocate memory using delete [] - the source memory allocation function may\n     * require a call to delete to deallocate the memory */\n    delete [] data;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    CWE78_OS_Command_Injection__char_file_w32_execv_82_base* baseObject = new CWE78_OS_Command_Injection__char_file_w32_execv_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = BASEPATH;\n    data = dataBuffer;\n    CWE23_Relative_Path_Traversal__wchar_t_console_ofstream_84_bad * badObject = new CWE23_Relative_Path_Traversal__wchar_t_console_ofstream_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE23 - Relative Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE126_Buffer_Overread__CWE129_listen_socket_31_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        int dataCopy = data;\n        int data = dataCopy;\n        {\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to access an index of the array that is above the upper bound\n             * This check does not check the upper bounds of the array index */\n            if (data >= 0)\n            {\n                printIntLine(buffer[data]);\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Overread"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_fscanf_sub_45_bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE191_Integer_Underflow__int_fscanf_sub_45_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE338_Weak_PRNG__w32_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* FLAW: Use of rand() as a PRNG */\n            int data = rand();\n            printIntLine(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE338 - Use of Cryptographically Weak PRNG"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE327_Use_Broken_Crypto__w32_RC5_16_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE197_Numeric_Truncation_Error__short_rand_06_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_fscanf_square_04_bad()\n{\n    unsigned int data;\n    data = 0;\n    if(STATIC_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Use a value input from the console */\n        fscanf (stdin, \"%u\", &data);\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* POTENTIAL FLAW: if (data*data) > UINT_MAX, this will overflow */\n            unsigned int result = data * data;\n            printUnsignedLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    badSource(data);\n    {\n        char source[100];\n        char dest[100] = \"\";\n        memset(source, 'A', 100-1);\n        source[100-1] = '\\0';\n        if (data < 100)\n        {\n            /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,\n             * the sign conversion could result in a very large number */\n            memmove(dest, source, data);\n            dest[data] = '\\0'; /* NULL terminate */\n        }\n        printLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    list<int> dataList;\n    /* Initialize data */\n    data = -1;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    badSink(dataList);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE126 - Buffer Overread"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__int64_t_realloc_65_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FLAW: Use a negative number */\n    data = -1;\n    CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_45_bad()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_45_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_char_declare_07_bad()\n{\n    char * data;\n    data = NULL; /* Initialize data */\n    if(staticFive==5)\n    {\n        {\n            /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n            char dataBuffer[100];\n            memset(dataBuffer, 'A', 100-1); /* fill with 'A's */\n            dataBuffer[100-1] = '\\0'; /* null terminate */\n            data = dataBuffer;\n        }\n    }\n    printLine(data);\n    /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */\n    free(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE284_Improper_Access_Control__w32_wchar_t_CreateWindowStation_18_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_32_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_51_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__fscanf_for_loop_01_bad()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    /* POTENTIAL FLAW: Read count from the console using fscanf() */\n    fscanf(stdin, \"%d\", &count);\n    {\n        size_t i = 0;\n        /* POTENTIAL FLAW: For loop using count as the loop variant and no validation */\n        for (i = 0; i < (size_t)count; i++)\n        {\n            printLine(\"Hello\");\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_listen_socket_popen_07_bad()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(staticFive==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pipe;\n        /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrue())\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n            }\n        }\n    }\n    {\n        ifstream inputFile;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        inputFile.open((char *)data);\n        inputFile.close();\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__wchar_t_realloc_12_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__char_fprintf_16_bad()\n{\n    while(1)\n    {\n        /* FLAW: Do not check the return value */\n        fprintf(stdout, \"%s\\n\", \"string\");\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE252 - Unchecked Return Value"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_console_vfprintf_04_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = strlen(data);\n            /* if there is room in data, read into it from the console */\n            if (100-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgets() */\n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        badVaSinkB(data, data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (FILENAME_MAX-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    badSink_b(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_06_bad()\n{\n    char * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Allocate and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = (char *)malloc(50*sizeof(char));\n        if (data == NULL) {exit(-1);}\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL; /* Initialize data */\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* FLAW: data is allocated on the stack and deallocated in the BadSink */\n            char dataBuffer;\n            dataBuffer = 'A';\n            data = &dataBuffer;\n        }\n    }\n    printHexCharLine(*data);\n    /* POTENTIAL FLAW: Possibly deallocating memory allocated on the stack */\n    delete data;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE590 - Free Memory Not on Heap"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE457_Use_of_Uninitialized_Variable__int_array_alloca_partial_init_02_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n    {\n        /* Read input from the console */\n        size_t dataLen = wcslen(data);\n        /* if there is room in data, read into it from the console */\n        if (FILENAME_MAX-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgetws() */\n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int fileDesc;\n        /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n        fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n        if (fileDesc != -1)\n        {\n            CLOSE(fileDesc);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_17_bad()\n{\n    int i;\n    int data;\n    /* Initialize data */\n    data = -1;\n    for(i = 0; i < 1; i++)\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    /* Assume we want to allocate a relatively small buffer */\n    if (data < 100)\n    {\n        /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,\n         * the conversion will cause malloc() to allocate a very large amount of data or fail */\n        char * dataBuffer = (char *)malloc(data);\n        if (dataBuffer == NULL) {exit(-1);}\n        /* Do something with dataBuffer */\n        memset(dataBuffer, 'A', data-1);\n        dataBuffer[data-1] = '\\0';\n        printLine(dataBuffer);\n        free(dataBuffer);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_connect_socket_predec_44_bad()\n{\n    int data;\n    /* define a function pointer */\n    void (*funcPtr) (int) = badSink;\n    /* Initialize data */\n    data = 0;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate the string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_02_bad()\n{\n    int64_t * data;\n    /* Initialize data */\n    data = NULL;\n    if(1)\n    {\n        /* INCIDENTAL: CWE-467 (Use of sizeof() on a pointer type) */\n        /* FLAW: Using sizeof the pointer and not the data type in malloc() */\n        data = (int64_t *)malloc(sizeof(data));\n        if (data == NULL) {exit(-1);}\n        *data = 2147483643LL;\n    }\n    /* POTENTIAL FLAW: Attempt to use data, which may not have enough memory allocated */\n    printLongLongLine(*data);\n    free(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__fgets_sleep_41_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_18_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_83_bad badObject(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int64_t * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (int64_t *)calloc(100, sizeof(int64_t));\n    if (data == NULL) {exit(-1);}\n    badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE338_Weak_PRNG__w32_10_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int64_t_rand_multiply_15_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61b_badSource(data);\n    /* Assume we want to allocate a relatively small buffer */\n    if (data < 100)\n    {\n        /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,\n         * the conversion will cause malloc() to allocate a very large amount of data or fail */\n        char * dataBuffer = (char *)malloc(data);\n        if (dataBuffer == NULL) {exit(-1);}\n        /* Do something with dataBuffer */\n        memset(dataBuffer, 'A', data-1);\n        dataBuffer[data-1] = '\\0';\n        printLine(dataBuffer);\n        free(dataBuffer);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_22_bad()\n{\n    twoIntsStruct * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_22_badGlobal = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_22_badSource(data);\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n            free(data);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__unsigned_int_fscanf_predec_04_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE506_Embedded_Malicious_Code__w32_base64_encoded_payload_16_bad()\n{\n    while(1)\n    {\n        {\n            /* FLAW: encoded \"calc.exe\" */\n            char * encodedPayload = \"Y2FsYy5leGU=\";\n            BYTE * decodedPayload = NULL;\n            DWORD requiredLength;\n            do\n            {\n                /* Calculate the number of bytes needed to decode */\n                if (!CryptStringToBinaryA(encodedPayload,\n                                          strlen(encodedPayload),\n                                          CRYPT_STRING_BASE64,\n                                          NULL,\n                                          &requiredLength,\n                                          NULL,\n                                          NULL))\n                {\n                    break;\n                }\n                /* Allocate memory for the decoded message */\n                decodedPayload = (BYTE*) malloc(requiredLength + 1);\n                if (decodedPayload == NULL)\n                {\n                    break;\n                }\n                /* Decode */\n                if (!CryptStringToBinaryA(encodedPayload,\n                                          strlen(encodedPayload),\n                                          CRYPT_STRING_BASE64,\n                                          decodedPayload,\n                                          &requiredLength,\n                                          NULL,\n                                          NULL))\n                {\n                    break;\n                }\n                /* NULL terminate */\n                decodedPayload[requiredLength] = '\\0';\n                if (system((char*)decodedPayload) <= 0)\n                {\n                    printLine(\"command execution failed!\");\n                    exit(1);\n                }\n            }\n            while (0);\n            free(decodedPayload);\n        }\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE506 - Embedded Malicious Code"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__char_alloca_memcpy_14_bad()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    if(globalFive==5)\n    {\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        memcpy(data, source, 100*sizeof(char));\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__float_connect_socket_34_bad()\n{\n    float data;\n    CWE369_Divide_by_Zero__float_connect_socket_34_unionType myUnion;\n    /* Initialize data */\n    data = 0.0F;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        SOCKET connectSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* POTENTIAL FLAW: Use a value input from the network */\n            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to float */\n            data = (float)atof(inputBuffer);\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    myUnion.unionFirst = data;\n    {\n        float data = myUnion.unionSecond;\n        {\n            /* POTENTIAL FLAW: Possibly divide by zero */\n            int result = (int)(100.0 / data);\n            printIntLine(result);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_console_vfprintf_04_good()\n{\n    goodG2B1();\n    goodG2B2();\n    goodB2G1();\n    goodB2G2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_w32spawnl_54_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_18_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__rand_sleep_64_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_execlp_32_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_51_bad()\n{\n    char * data;\n    data = (char *)malloc(100*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    data[0] = '\\0';\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_51b_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE761 - Free Pointer not at Start of Buffer"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        /* FLAW: puts() might fail, in which case the return value will be EOF (-1), but\n         * we are checking to see if the return value is 0 */\n        if (PUTS(\"string\") == 0)\n        {\n            printLine(\"puts failed!\");\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE253 - Incorrect Check of Return Value"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_environment_w32_execvp_67_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE415_Double_Free__malloc_free_struct_42_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE590_Free_Memory_Not_on_Heap__free_char_declare_66_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_12_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            char inputBuffer[CHAR_ARRAY_SIZE];\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* NUL-terminate the string */\n                inputBuffer[recvResult] = '\\0';\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    else\n    {\n        /* FIX: Set data to a relatively small number greater than zero */\n        data = 20;\n    }\n    {\n        size_t i;\n        int *intPointer;\n        /* POTENTIAL FLAW: if data * sizeof(int) > SIZE_MAX, overflows to a small value\n         * so that the for loop doing the initialization causes a buffer overflow */\n        intPointer = (int*)malloc(data * sizeof(int));\n        if (intPointer == NULL) {exit(-1);}\n        for (i = 0; i < (size_t)data; i++)\n        {\n            intPointer[i] = 0; /* Potentially writes beyond the boundary of intPointer */\n        }\n        printIntLine(intPointer[0]);\n        free(intPointer);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE680 - Integer Overflow to Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_13_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_68_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__wchar_t_fputs_11_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__int_malloc_13_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    if(staticTrue)\n    {\n        {\n            twoIntsStruct * pointer = new twoIntsStruct;\n            twoIntsStruct data = *pointer; /* FLAW: the value pointed to by pointer is undefined */\n            delete pointer;\n            printIntLine(data.intOne);\n            printIntLine(data.intTwo);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE758 - Undefined Behavior"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE617_Reachable_Assertion__fgets_68_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE617_Reachable_Assertion__fgets_68_badData = data;\n    CWE617_Reachable_Assertion__fgets_68b_badSink();\n}\n\n#endif /* OMITBAD */", "target_text": "CWE617 - Reachable Assertion"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__char_fscanf_square_66_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    /* Initialize data */\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        data = new wchar_t;\n        /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */\n        delete data;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n        /* POTENTIAL FLAW: Possibly deleting memory twice */\n        delete data;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE415 - Double Free"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_67_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE284_Improper_Access_Control__w32_char_CreateFile_06_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    size_t data;\n    /* Initialize data */\n    data = 0;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = rand();\n    }\n    if(GLOBAL_CONST_TRUE)\n    {\n        {\n            wchar_t * myString;\n            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough\n             * for the wcscpy() function to not cause a buffer overflow */\n            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */\n            if (data > wcslen(HELLO_STRING))\n            {\n                myString = new wchar_t[data];\n                /* Copy a small string into myString */\n                wcscpy(myString, HELLO_STRING);\n                printWLine(myString);\n                delete [] myString;\n            }\n            else\n            {\n                printLine(\"Input is less than the length of the source string\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE789 - Uncontrolled Memory Allocation"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = strlen(data);\n            /* if there is room in data, read into it from the console */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgets() */\n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileA(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE506_Embedded_Malicious_Code__w32_base64_encoded_payload_16_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    map<int, TwoIntsClass *> dataMap;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires delete to free the memory */\n    data = new TwoIntsClass;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE758_Undefined_Behavior__int64_t_alloca_use_05_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    size_t data;\n    /* Initialize data */\n    data = 0;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%zu\", &data);\n    CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82_base* baseObject = new CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */", "target_text": "CWE789 - Uncontrolled Memory Allocation"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = badSink;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires free() to free the memory */\n    data = (wchar_t *)calloc(100, sizeof(wchar_t));\n    if (data == NULL) {exit(-1);}\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE253_Incorrect_Check_of_Function_Return_Value__char_puts_08_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    long * data;\n    /* Initialize data */\n    data = NULL;\n    if(1)\n    {\n        data = new long;\n        *data = 5L;\n        /* POTENTIAL FLAW: Delete data in the source - the bad sink attempts to use data */\n        delete data;\n    }\n    if(1)\n    {\n        /* POTENTIAL FLAW: Use of data that may have been deleted */\n        printLongLine(*data);\n        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not deleted */\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE416 - Use After Free"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__char_fscanf_multiply_44_bad()\n{\n    char data;\n    /* define a function pointer */\n    void (*funcPtr) (char) = badSink;\n    data = ' ';\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%c\", &data);\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = new char[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (FILENAME_MAX-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            ofstream outputFile;\n            /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n            outputFile.open((char *)data);\n            outputFile.close();\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE464_Addition_of_Data_Structure_Sentinel__basic_41_bad()\n{\n    char data;\n    data = ' ';\n    {\n        char charArraySource[2];\n        charArraySource[0] = (char)getc(stdin);\n        charArraySource[1] = '\\0';\n        /* FLAW: If the character entered on the command line is not an int,\n         * a null value will be returned */\n        data = (char)atoi(charArraySource);\n    }\n    CWE464_Addition_of_Data_Structure_Sentinel__basic_41_badSink(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE464 - Addition of Data Structure Sentinel"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE457_Use_of_Uninitialized_Variable__struct_pointer_63_bad()\n{\n    twoIntsStruct * data;\n    /* POTENTIAL FLAW: Don't initialize data */\n    ; /* empty statement needed for some flow variants */\n    CWE457_Use_of_Uninitialized_Variable__struct_pointer_63b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE457 - Use of Uninitialized Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE546_Suspicious_Comment__BUG_03_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__malloc_wchar_t_memcpy_07_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    badSink(dataMap);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE195 - Signed to Unsigned Conversion Error"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__listen_socket_malloc_65_bad()\n{\n    short data;\n    /* define a function pointer */\n    void (*funcPtr) (short) = CWE194_Unexpected_Sign_Extension__listen_socket_malloc_65b_badSink;\n    /* Initialize data */\n    data = 0;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        int tempInt;\n        struct sockaddr_in service;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        char inputBuffer[CHAR_ARRAY_SIZE];\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);\n            /* FLAW: Use a value input from the network */\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* NUL-terminate string */\n            inputBuffer[recvResult] = '\\0';\n            /* Convert to short - ensure int to short conversion will be successful and if\n             * not ensure that data will be negative */\n            tempInt = atoi(inputBuffer);\n            if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)\n            {\n                data = -1;\n            }\n            else\n            {\n                data = tempInt;\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE127_Buffer_Underread__wchar_t_declare_memcpy_09_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    wmemset(dataBuffer, L'A', 100-1);\n    dataBuffer[100-1] = L'\\0';\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Set data pointer to before the allocated memory buffer */\n        data = dataBuffer - 8;\n    }\n    {\n        wchar_t dest[100];\n        wmemset(dest, L'C', 100-1); /* fill with 'C's */\n        dest[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copy from a memory location located before the source buffer */\n        memcpy(dest, data, 100*sizeof(wchar_t));\n        /* Ensure null termination */\n        dest[100-1] = L'\\0';\n        printWLine(dest);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE127 - Buffer Under-read"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);\n        }\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    badSink(dataVector);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_17_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE401_Memory_Leak__strdup_wchar_t_61_bad()\n{\n    wchar_t * data;\n    data = NULL;\n    data = CWE401_Memory_Leak__strdup_wchar_t_61b_badSource(data);\n    /* POTENTIAL FLAW: No deallocation of memory */\n    /* no deallocation */\n    ; /* empty statement needed for some flow variants */\n}\n\n#endif /* OMITBAD */", "target_text": "CWE401 - Memory Leak"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_68_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE328_Reversible_One_Way_Hash__w32_MD5_12_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__fgets_malloc_22_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_rand_sub_67_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__rand_malloc_68_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    badSource(data);\n    {\n        FILE *pipe;\n        /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n        pipe = POPEN(data, L\"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_66_bad()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_66b_badSink(dataArray);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_file_execlp_32_bad()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        /* execlp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__int_fgets_add_53_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE194_Unexpected_Sign_Extension__fscanf_strncpy_64_bad()\n{\n    short data;\n    /* Initialize data */\n    data = 0;\n    /* FLAW: Use a value input from the console using fscanf() */\n    fscanf (stdin, \"%hd\", &data);\n    CWE194_Unexpected_Sign_Extension__fscanf_strncpy_64b_badSink(&data);\n}\n\n#endif /* OMITBAD */", "target_text": "CWE194 - Unexpected Sign Extension"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__unsigned_int_max_add_54_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE571_Expression_Always_True__string_equals_01_bad() \n{\n    char charString[10] = \"true\";\n\n    /* FLAW: This expression is always true */\n    if (strcmp(charString, \"true\") == 0) \n    {\n        printLine(\"Always prints\");\n    }\n}\n\n#endif /* OMITBAD */", "target_text": "CWE571 - Unknown Vulnerability"}
