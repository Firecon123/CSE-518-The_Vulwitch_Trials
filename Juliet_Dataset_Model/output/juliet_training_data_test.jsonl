{"input_text": "<vuln_detect> <lang> C\nvoid CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_bad()\n{\n    char * cryptoKey;\n    char cryptoKeyBuffer[100] = \"\";\n    cryptoKey = cryptoKeyBuffer;\n    /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */\n    strcpy(cryptoKey, CRYPTO_KEY);\n    CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_badData = cryptoKey;\n    badSink();\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2BSink()\n{\n    char * cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_goodG2BData;\n    {\n        HCRYPTPROV hCryptProv;\n        HCRYPTKEY hKey;\n        HCRYPTHASH hHash;\n        char toBeEncrypted[] = \"String to be encrypted\";\n        DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);\n        BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */\n        /* Copy plaintext (without NUL terminator) into byte buffer */\n        memcpy(encrypted, toBeEncrypted, encryptedLen);\n        /* Try to get a context with and without a new key set */\n        if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))\n        {\n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))\n            {\n                printLine(\"Error in acquiring cryptographic context\");\n                exit(1);\n            }\n        }\n        /* Create Hash handle */\n        if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n        {\n            printLine(\"Error in creating hash\");\n            exit(1);\n        }\n        /* Hash the cryptoKey */\n        if(!CryptHashData(hHash, (BYTE *) cryptoKey, strlen(cryptoKey)*sizeof(char), 0))\n        {\n            printLine(\"Error in hashing cryptoKey\");\n            exit(1);\n        }\n        /* Derive an AES key from the Hashed cryptoKey */\n        if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n        {\n            printLine(\"Error in CryptDeriveKey\");\n            exit(1);\n        }\n        /* POTENTIAL FLAW: Possibly using a hardcoded crypto key */\n        /* Use the derived key to encrypt something */\n        if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted)))\n        {\n            printLine(\"Error in CryptEncrypt\");\n            exit(1);\n        }\n        /* use encrypted block */\n        printBytesLine(encrypted, encryptedLen);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n    }\n}\n\nstatic void goodG2B()\n{\n    char * cryptoKey;\n    char cryptoKeyBuffer[100] = \"\";\n    cryptoKey = cryptoKeyBuffer;\n    {\n        size_t cryptoKeyLen = strlen(cryptoKey);\n        /* if there is room in cryptoKey, read into it from the console */\n        if(100-cryptoKeyLen > 1)\n        {\n            /* FIX: Obtain the hash input from the console */\n            if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                cryptoKey[cryptoKeyLen] = '\\0';\n            }\n            /* The next 3 lines remove the carriage return from the string that is\n             * inserted by fgets() */\n            cryptoKeyLen = strlen(cryptoKey);\n            if (cryptoKeyLen > 0)\n            {\n                cryptoKey[cryptoKeyLen-1] = '\\0';\n            }\n        }\n    }\n    CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_goodG2BData = cryptoKey;\n    goodG2BSink();\n}\n\nvoid CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE321 - Use of Hard-coded Cryptographic Key"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_connect_socket_predec_61_bad()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    data = CWE191_Integer_Underflow__int_connect_socket_predec_61b_badSource(data);\n    {\n        /* POTENTIAL FLAW: Decrementing data could cause an underflow */\n        --data;\n        int result = data;\n        printIntLine(result);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nint CWE191_Integer_Underflow__int_connect_socket_predec_61b_goodG2BSource(int data);\n\nstatic void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    data = CWE191_Integer_Underflow__int_connect_socket_predec_61b_goodG2BSource(data);\n    {\n        /* POTENTIAL FLAW: Decrementing data could cause an underflow */\n        --data;\n        int result = data;\n        printIntLine(result);\n    }\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nint CWE191_Integer_Underflow__int_connect_socket_predec_61b_goodB2GSource(int data);\n\nstatic void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = 0;\n    data = CWE191_Integer_Underflow__int_connect_socket_predec_61b_goodB2GSource(data);\n    /* FIX: Add a check to prevent an underflow from occurring */\n    if (data > INT_MIN)\n    {\n        --data;\n        int result = data;\n        printIntLine(result);\n    }\n    else\n    {\n        printLine(\"data value is too large to perform arithmetic safely.\");\n    }\n}\n\nvoid CWE191_Integer_Underflow__int_connect_socket_predec_61_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE191_Integer_Underflow__int_connect_socket_predec_61_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE191_Integer_Underflow__int_connect_socket_predec_61_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int_connect_socket_predec_61_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE191_Integer_Underflow__int_connect_socket_predec_61_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE191_Integer_Underflow__int_connect_socket_predec_61_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_32_bad()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        /* wexecl - specify the path where the command is located */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Append a fixed string to data (not user / external input) */\n        wcscat(data, L\"*.*\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        /* wexecl - specify the path where the command is located */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n    }\n}\n\nvoid CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_32_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_32_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_32_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_32_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_32_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_32_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            int fileDesc;\n            /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n            fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[FILENAME_MAX] = \"\";\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n#ifdef _WIN32\n        /* FIX: Use a fixed, full path and file name */\n        strcat(data, \"c:\\\\temp\\\\file.txt\");\n#else\n        /* FIX: Use a fixed, full path and file name */\n        strcat(data, \"/tmp/file.txt\");\n#endif\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            int fileDesc;\n            /* POTENTIAL FLAW: Possibly opening a file without validating the file name or path */\n            fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);\n            if (fileDesc != -1)\n            {\n                CLOSE(fileDesc);\n            }\n        }\n    }\n}\n\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nusing namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_32; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nusing namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_32; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_console_vfprintf_05_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = wcslen(data);\n            /* if there is room in data, read into it from the console */\n            if (100-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgetws() */\n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    if(staticTrue)\n    {\n        badVaSinkB(data, data);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\nstatic void goodB2G1VaSinkG(wchar_t * data, ...)\n{\n    {\n        va_list args;\n        va_start(args, data);\n        /* FIX: Specify the format disallowing a format string vulnerability */\n        vfwprintf(stdout, L\"%s\", args);\n        va_end(args);\n    }\n}\n\n/* goodB2G1() - use badsource and goodsink by changing the second staticTrue to staticFalse */\nstatic void goodB2G1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = wcslen(data);\n            /* if there is room in data, read into it from the console */\n            if (100-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgetws() */\n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        goodB2G1VaSinkG(data, data);\n    }\n}\n\nstatic void goodB2G2VaSinkG(wchar_t * data, ...)\n{\n    {\n        va_list args;\n        va_start(args, data);\n        /* FIX: Specify the format disallowing a format string vulnerability */\n        vfwprintf(stdout, L\"%s\", args);\n        va_end(args);\n    }\n}\n\n/* goodB2G2() - use badsource and goodsink by reversing the blocks in the second if */\nstatic void goodB2G2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = wcslen(data);\n            /* if there is room in data, read into it from the console */\n            if (100-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgetws() */\n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    if(staticTrue)\n    {\n        goodB2G2VaSinkG(data, data);\n    }\n}\n\nstatic void goodG2B1VaSinkB(wchar_t * data, ...)\n{\n    {\n        va_list args;\n        va_start(args, data);\n        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n        vfwprintf(stdout, data, args);\n        va_end(args);\n    }\n}\n\n/* goodG2B1() - use goodsource and badsink by changing the first staticTrue to staticFalse */\nstatic void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a fixed string that does not contain a format specifier */\n        wcscpy(data, L\"fixedstringtest\");\n    }\n    if(staticTrue)\n    {\n        goodG2B1VaSinkB(data, data);\n    }\n}\n\nstatic void goodG2B2VaSinkB(wchar_t * data, ...)\n{\n    {\n        va_list args;\n        va_start(args, data);\n        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n        vfwprintf(stdout, data, args);\n        va_end(args);\n    }\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the first if */\nstatic void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        /* FIX: Use a fixed string that does not contain a format specifier */\n        wcscpy(data, L\"fixedstringtest\");\n    }\n    if(staticTrue)\n    {\n        goodG2B2VaSinkB(data, data);\n    }\n}\n\nvoid CWE134_Uncontrolled_Format_String__wchar_t_console_vfprintf_05_good()\n{\n    goodG2B1();\n    goodG2B2();\n    goodB2G1();\n    goodB2G2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE134_Uncontrolled_Format_String__wchar_t_console_vfprintf_05_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE134_Uncontrolled_Format_String__wchar_t_console_vfprintf_05_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_console_vfprintf_05_good()\n{\n    goodG2B1();\n    goodG2B2();\n    goodB2G1();\n    goodB2G2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE134_Uncontrolled_Format_String__wchar_t_console_vfprintf_05_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE134_Uncontrolled_Format_String__wchar_t_console_vfprintf_05_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    /* FLAW: Set data pointer to before the allocated memory buffer */\n    data = dataBuffer - 8;\n    const CWE124_Buffer_Underwrite__char_alloca_cpy_81_base& baseObject = CWE124_Buffer_Underwrite__char_alloca_cpy_81_bad();\n    baseObject.action(data);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    memset(dataBuffer, 'A', 100-1);\n    dataBuffer[100-1] = '\\0';\n    /* FIX: Set data pointer to the allocated memory buffer */\n    data = dataBuffer;\n    const CWE124_Buffer_Underwrite__char_alloca_cpy_81_base& baseObject = CWE124_Buffer_Underwrite__char_alloca_cpy_81_goodG2B();\n    baseObject.action(data);\n}\n\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE124_Buffer_Underwrite__char_alloca_cpy_81; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE124_Buffer_Underwrite__char_alloca_cpy_81; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_82_bad;\n    baseObject->action(data);\n    delete baseObject;\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n#ifdef _WIN32\n    /* FIX: Use a fixed, full path and file name */\n    wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n    /* FIX: Use a fixed, full path and file name */\n    wcscat(data, L\"/tmp/file.txt\");\n#endif\n    CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_82_goodG2B;\n    baseObject->action(data);\n    delete baseObject;\n}\n\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_82; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_82; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    badStatic = 1; /* true */\n    data = badSource(data);\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0].intOne);\n            delete [] data;\n        }\n    }\n    ;\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* The static variables below are used to drive control flow in the source functions. */\nstatic int goodG2B1Static = 0;\nstatic int goodG2B2Static = 0;\n\n/* goodG2B1() - use goodsource and badsink by setting the static variable to false instead of true */\nstatic TwoIntsClass * goodG2B1Source(TwoIntsClass * data)\n{\n    if(goodG2B1Static)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new TwoIntsClass[100];\n    }\n    return data;\n}\n\nstatic void goodG2B1()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    goodG2B1Static = 0; /* false */\n    data = goodG2B1Source(data);\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0].intOne);\n            delete [] data;\n        }\n    }\n    ;\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if in the source function */\nstatic TwoIntsClass * goodG2B2Source(TwoIntsClass * data)\n{\n    if(goodG2B2Static)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new TwoIntsClass[100];\n    }\n    return data;\n}\n\nstatic void goodG2B2()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    goodG2B2Static = 1; /* true */\n    data = goodG2B2Source(data);\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0].intOne);\n            delete [] data;\n        }\n    }\n    ;\n}\n\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n    }\n    else\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() - use goodsource and badsink by changing the \"if\" so that\n   both branches use the GoodSource */\nstatic void goodG2B()\n{\n    char * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    else\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_12; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_12; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__CWE839_fgets_68_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE124_Buffer_Underwrite__CWE839_fgets_68_badData = data;\n    CWE124_Buffer_Underwrite__CWE839_fgets_68b_badSink();\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good function declarations */\nvoid CWE124_Buffer_Underwrite__CWE839_fgets_68b_goodG2BSink();\nvoid CWE124_Buffer_Underwrite__CWE839_fgets_68b_goodB2GSink();\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n    * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE124_Buffer_Underwrite__CWE839_fgets_68_goodG2BData = data;\n    CWE124_Buffer_Underwrite__CWE839_fgets_68b_goodG2BSink();\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nstatic void goodB2G()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE124_Buffer_Underwrite__CWE839_fgets_68_goodB2GData = data;\n    CWE124_Buffer_Underwrite__CWE839_fgets_68b_goodB2GSink();\n}\n\nvoid CWE124_Buffer_Underwrite__CWE839_fgets_68_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE124_Buffer_Underwrite__CWE839_fgets_68_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE124_Buffer_Underwrite__CWE839_fgets_68_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE124_Buffer_Underwrite__CWE839_fgets_68_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE124_Buffer_Underwrite__CWE839_fgets_68_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE124_Buffer_Underwrite__CWE839_fgets_68_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticTrue)\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    {\n        size_t dataBytes,i;\n        int *intPointer;\n        /* POTENTIAL FLAW: dataBytes may overflow to a small value */\n        dataBytes = data * sizeof(int); /* sizeof array in bytes */\n        intPointer = (int*)new char[dataBytes];\n        for (i = 0; i < (size_t)data; i++)\n        {\n            intPointer[i] = 0; /* may write beyond limit of intPointer if integer overflow occured above */\n        }\n        printIntLine(intPointer[0]);\n        delete [] intPointer;\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B1() - use goodsource and badsink by changing the staticTrue to staticFalse */\nstatic void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set data to a relatively small number greater than zero */\n        data = 20;\n    }\n    {\n        size_t dataBytes,i;\n        int *intPointer;\n        /* POTENTIAL FLAW: dataBytes may overflow to a small value */\n        dataBytes = data * sizeof(int); /* sizeof array in bytes */\n        intPointer = (int*)new char[dataBytes];\n        for (i = 0; i < (size_t)data; i++)\n        {\n            intPointer[i] = 0; /* may write beyond limit of intPointer if integer overflow occured above */\n        }\n        printIntLine(intPointer[0]);\n        delete [] intPointer;\n    }\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if statement */\nstatic void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticTrue)\n    {\n        /* FIX: Set data to a relatively small number greater than zero */\n        data = 20;\n    }\n    {\n        size_t dataBytes,i;\n        int *intPointer;\n        /* POTENTIAL FLAW: dataBytes may overflow to a small value */\n        dataBytes = data * sizeof(int); /* sizeof array in bytes */\n        intPointer = (int*)new char[dataBytes];\n        for (i = 0; i < (size_t)data; i++)\n        {\n            intPointer[i] = 0; /* may write beyond limit of intPointer if integer overflow occured above */\n        }\n        printIntLine(intPointer[0]);\n        delete [] intPointer;\n    }\n}\n\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_05; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE680 - Integer Overflow to Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_05; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__fscanf_fwrite_31_bad()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    /* POTENTIAL FLAW: Read count from the console using fscanf() */\n    fscanf(stdin, \"%d\", &count);\n    {\n        int countCopy = count;\n        int count = countCopy;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_bad.txt\";\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            /* POTENTIAL FLAW: For loop using count as the loop variant and no validation\n             * This can cause a file to become very large */\n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n                {\n                    exit(1);\n                }\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    /* FIX: Use a relatively small number */\n    count = 20;\n    {\n        int countCopy = count;\n        int count = countCopy;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_bad.txt\";\n            pFile = fopen(filename, \"w+\");\n            if (pFile == NULL)\n            {\n                exit(1);\n            }\n            /* POTENTIAL FLAW: For loop using count as the loop variant and no validation\n             * This can cause a file to become very large */\n            for (i = 0; i < (size_t)count; i++)\n            {\n                if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile))\n                {\n                    exit(1);\n                }\n            }\n            if (pFile)\n            {\n                fclose(pFile);\n            }\n        }\n    }\n}\n\n/* goodB2G() uses the BadSource with the GoodSink */\nstatic void goodB2G()\n{\n    int count;\n    /* Initialize count */\n    count = -1;\n    /* POTENTIAL FLAW: Read count from the console using fscanf() */\n    fscanf(stdin, \"%d\", &count);\n    {\n        int countCopy = count;\n        int count = countCopy;\n        {\n            size_t i = 0;\n            FILE *pFile = NULL;\n            const char *filename = \"output_good.txt\";\n            /* FIX: Validate count before using it as the for loop variant to write to a file */\n            if (count > 0 && count <= 20)\n            {\n                pFile = fopen(filename, \"w+\");\n                if (pFile == NULL)\n                {\n                    exit(1);\n                }\n                for (i = 0; i < (size_t)count; i++)\n                {\n                    if (strlen(SENTENCE) != fwrite(SENTENCE, sizeof(char), strlen(SENTENCE), pFile)) exit(1);\n                }\n                if (pFile)\n                {\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n}\n\nvoid CWE400_Resource_Exhaustion__fscanf_fwrite_31_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE400_Resource_Exhaustion__fscanf_fwrite_31_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE400_Resource_Exhaustion__fscanf_fwrite_31_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE400 - Resource Exhaustion"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE400_Resource_Exhaustion__fscanf_fwrite_31_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE400_Resource_Exhaustion__fscanf_fwrite_31_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE400_Resource_Exhaustion__fscanf_fwrite_31_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE563_Unused_Variable__unused_value_long_14_bad()\n{\n    long data;\n    if(globalFive==5)\n    {\n        /* POTENTIAL FLAW: Initialize, but do not use data */\n        data = 5L;\n    }\n    if(globalFive==5)\n    {\n        /* POTENTIAL FLAW: Possibly over-write the initial value of data before using it */\n        data = 10L;\n        printLongLine(data);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodB2G1() - use badsource and goodsink by changing the second globalFive==5 to globalFive!=5 */\nstatic void goodB2G1()\n{\n    long data;\n    if(globalFive==5)\n    {\n        /* POTENTIAL FLAW: Initialize, but do not use data */\n        data = 5L;\n    }\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use data without over-writing its value */\n        printLongLine(data);\n    }\n}\n\n/* goodB2G2() - use badsource and goodsink by reversing the blocks in the second if */\nstatic void goodB2G2()\n{\n    long data;\n    if(globalFive==5)\n    {\n        /* POTENTIAL FLAW: Initialize, but do not use data */\n        data = 5L;\n    }\n    if(globalFive==5)\n    {\n        /* FIX: Use data without over-writing its value */\n        printLongLine(data);\n    }\n}\n\n/* goodG2B1() - use goodsource and badsink by changing the first globalFive==5 to globalFive!=5 */\nstatic void goodG2B1()\n{\n    long data;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize and use data before it is overwritten */\n        data = 5L;\n        printLongLine(data);\n    }\n    if(globalFive==5)\n    {\n        /* POTENTIAL FLAW: Possibly over-write the initial value of data before using it */\n        data = 10L;\n        printLongLine(data);\n    }\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the first if */\nstatic void goodG2B2()\n{\n    long data;\n    if(globalFive==5)\n    {\n        /* FIX: Initialize and use data before it is overwritten */\n        data = 5L;\n        printLongLine(data);\n    }\n    if(globalFive==5)\n    {\n        /* POTENTIAL FLAW: Possibly over-write the initial value of data before using it */\n        data = 10L;\n        printLongLine(data);\n    }\n}\n\nvoid CWE563_Unused_Variable__unused_value_long_14_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE563_Unused_Variable__unused_value_long_14_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE563_Unused_Variable__unused_value_long_14_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE563 - Unused Variable"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE563_Unused_Variable__unused_value_long_14_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE563_Unused_Variable__unused_value_long_14_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE563_Unused_Variable__unused_value_long_14_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char * dataBuffer = new char[100];\n            memset(dataBuffer, 'A', 100-1);\n            dataBuffer[100-1] = '\\0';\n            /* FLAW: Set data pointer to before the allocated memory buffer */\n            data = dataBuffer - 8;\n        }\n    }\n    else\n    {\n        {\n            char * dataBuffer = new char[100];\n            memset(dataBuffer, 'A', 100-1);\n            dataBuffer[100-1] = '\\0';\n            /* FIX: Set data pointer to the allocated memory buffer */\n            data = dataBuffer;\n        }\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        memmove(data, source, 100*sizeof(char));\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n         * returned by new [] so can't safely call delete [] on it */\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() - use goodsource and badsink by changing the \"if\" so that\n   both branches use the GoodSource */\nstatic void goodG2B()\n{\n    char * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            char * dataBuffer = new char[100];\n            memset(dataBuffer, 'A', 100-1);\n            dataBuffer[100-1] = '\\0';\n            /* FIX: Set data pointer to the allocated memory buffer */\n            data = dataBuffer;\n        }\n    }\n    else\n    {\n        {\n            char * dataBuffer = new char[100];\n            memset(dataBuffer, 'A', 100-1);\n            dataBuffer[100-1] = '\\0';\n            /* FIX: Set data pointer to the allocated memory buffer */\n            data = dataBuffer;\n        }\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possibly copying data to memory before the destination buffer */\n        memmove(data, source, 100*sizeof(char));\n        /* Ensure the destination buffer is null terminated */\n        data[100-1] = '\\0';\n        printLine(data);\n        /* INCIDENTAL CWE-401: Memory Leak - data may not point to location\n         * returned by new [] so can't safely call delete [] on it */\n    }\n}\n\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE124_Buffer_Underwrite__new_char_memmove_12; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE124 - Buffer Underwrite"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE124_Buffer_Underwrite__new_char_memmove_12; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    CWE78_OS_Command_Injection__char_environment_w32_spawnlp_84_bad * badObject = new CWE78_OS_Command_Injection__char_environment_w32_spawnlp_84_bad(data);\n    delete badObject;\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    CWE78_OS_Command_Injection__char_environment_w32_spawnlp_84_goodG2B * goodG2BObject =  new CWE78_OS_Command_Injection__char_environment_w32_spawnlp_84_goodG2B(data);\n    delete goodG2BObject;\n}\n\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE78_OS_Command_Injection__char_environment_w32_spawnlp_84; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE78_OS_Command_Injection__char_environment_w32_spawnlp_84; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE415_Double_Free__malloc_free_long_31_bad()\n{\n    long * data;\n    /* Initialize data */\n    data = NULL;\n    data = (long *)malloc(100*sizeof(long));\n    if (data == NULL) {exit(-1);}\n    /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */\n    free(data);\n    {\n        long * dataCopy = data;\n        long * data = dataCopy;\n        /* POTENTIAL FLAW: Possibly freeing memory twice */\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    long * data;\n    /* Initialize data */\n    data = NULL;\n    data = (long *)malloc(100*sizeof(long));\n    if (data == NULL) {exit(-1);}\n    /* FIX: Do NOT free data in the source - the bad sink frees data */\n    {\n        long * dataCopy = data;\n        long * data = dataCopy;\n        /* POTENTIAL FLAW: Possibly freeing memory twice */\n        free(data);\n    }\n}\n\n/* goodB2G() uses the BadSource with the GoodSink */\nstatic void goodB2G()\n{\n    long * data;\n    /* Initialize data */\n    data = NULL;\n    data = (long *)malloc(100*sizeof(long));\n    if (data == NULL) {exit(-1);}\n    /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */\n    free(data);\n    {\n        long * dataCopy = data;\n        long * data = dataCopy;\n        /* do nothing */\n        /* FIX: Don't attempt to free the memory */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\nvoid CWE415_Double_Free__malloc_free_long_31_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE415_Double_Free__malloc_free_long_31_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE415_Double_Free__malloc_free_long_31_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE415 - Double Free"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE415_Double_Free__malloc_free_long_31_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE415_Double_Free__malloc_free_long_31_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE415_Double_Free__malloc_free_long_31_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fgets_divide_02_bad()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(1)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(1)\n    {\n        /* POTENTIAL FLAW: Possibly divide by zero */\n        printIntLine(100 / data);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodB2G1() - use badsource and goodsink by changing the second 1 to 0 */\nstatic void goodB2G1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(1)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: test for a zero denominator */\n        if( data != 0 )\n        {\n            printIntLine(100 / data);\n        }\n        else\n        {\n            printLine(\"This would result in a divide by zero\");\n        }\n    }\n}\n\n/* goodB2G2() - use badsource and goodsink by reversing the blocks in the second if */\nstatic void goodB2G2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(1)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(1)\n    {\n        /* FIX: test for a zero denominator */\n        if( data != 0 )\n        {\n            printIntLine(100 / data);\n        }\n        else\n        {\n            printLine(\"This would result in a divide by zero\");\n        }\n    }\n}\n\n/* goodG2B1() - use goodsource and badsink by changing the first 1 to 0 */\nstatic void goodG2B1()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value not equal to zero */\n        data = 7;\n    }\n    if(1)\n    {\n        /* POTENTIAL FLAW: Possibly divide by zero */\n        printIntLine(100 / data);\n    }\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the first if */\nstatic void goodG2B2()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(1)\n    {\n        /* FIX: Use a value not equal to zero */\n        data = 7;\n    }\n    if(1)\n    {\n        /* POTENTIAL FLAW: Possibly divide by zero */\n        printIntLine(100 / data);\n    }\n}\n\nvoid CWE369_Divide_by_Zero__int_fgets_divide_02_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE369_Divide_by_Zero__int_fgets_divide_02_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE369_Divide_by_Zero__int_fgets_divide_02_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE369 - Divide by Zero"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE369_Divide_by_Zero__int_fgets_divide_02_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE369_Divide_by_Zero__int_fgets_divide_02_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE369_Divide_by_Zero__int_fgets_divide_02_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B1() - use goodsource and badsink by changing the 5==5 to 5!=5 */\nstatic void goodG2B1()\n{\n    wchar_t * data;\n    data = NULL;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if statement */\nstatic void goodG2B2()\n{\n    wchar_t * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_03; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_03; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__short_fscanf_postinc_53_bad()\n{\n    short data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%hd\", &data);\n    CWE190_Integer_Overflow__short_fscanf_postinc_53b_badSink(data);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE190_Integer_Overflow__short_fscanf_postinc_53b_goodG2BSink(short data);\n\nstatic void goodG2B()\n{\n    short data;\n    data = 0;\n    /* FIX: Use a small, non-zero value that will not cause an overflow in the sinks */\n    data = 2;\n    CWE190_Integer_Overflow__short_fscanf_postinc_53b_goodG2BSink(data);\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE190_Integer_Overflow__short_fscanf_postinc_53b_goodB2GSink(short data);\n\nstatic void goodB2G()\n{\n    short data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a value input from the console */\n    fscanf (stdin, \"%hd\", &data);\n    CWE190_Integer_Overflow__short_fscanf_postinc_53b_goodB2GSink(data);\n}\n\nvoid CWE190_Integer_Overflow__short_fscanf_postinc_53_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE190_Integer_Overflow__short_fscanf_postinc_53_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE190_Integer_Overflow__short_fscanf_postinc_53_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE190 - Integer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE190_Integer_Overflow__short_fscanf_postinc_53_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE190_Integer_Overflow__short_fscanf_postinc_53_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE190_Integer_Overflow__short_fscanf_postinc_53_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52_bad()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52b_badSink(data);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good function declaration */\nvoid CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52b_goodG2BSink(wchar_t * data);\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52b_goodG2BSink(data);\n}\n\nvoid CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_52_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_connect_socket_popen_05_bad()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(staticTrue)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET connectSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a connect socket */\n                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (connectSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n                service.sin_port = htons(TCP_PORT);\n                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed, make sure to recv one\n                 * less char than is in the recv_buf in order to append a terminator */\n                /* Abort on error or the connection was closed */\n                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (connectSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(connectSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    {\n        FILE *pipe;\n        /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B1() - use goodsource and badsink by changing the staticTrue to staticFalse */\nstatic void goodG2B1()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Append a fixed string to data (not user / external input) */\n        strcat(data, \"*.*\");\n    }\n    {\n        FILE *pipe;\n        /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if statement */\nstatic void goodG2B2()\n{\n    char * data;\n    char data_buf[100] = FULL_COMMAND;\n    data = data_buf;\n    if(staticTrue)\n    {\n        /* FIX: Append a fixed string to data (not user / external input) */\n        strcat(data, \"*.*\");\n    }\n    {\n        FILE *pipe;\n        /* POTENTIAL FLAW: Execute command in data possibly leading to command injection */\n        pipe = POPEN(data, \"w\");\n        if (pipe != NULL)\n        {\n            PCLOSE(pipe);\n        }\n    }\n}\n\nvoid CWE78_OS_Command_Injection__char_connect_socket_popen_05_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__char_connect_socket_popen_05_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__char_connect_socket_popen_05_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_connect_socket_popen_05_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__char_connect_socket_popen_05_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__char_connect_socket_popen_05_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_01_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    badVaSink(data, data);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2BVaSink(wchar_t * data, ...)\n{\n    {\n        wchar_t dest[100] = L\"\";\n        va_list args;\n        va_start(args, data);\n        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n        _vsnwprintf(dest, 100-1, data, args);\n        va_end(args);\n        printWLine(dest);\n    }\n}\n\nstatic void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FIX: Use a fixed string that does not contain a format specifier */\n    wcscpy(data, L\"fixedstringtest\");\n    goodG2BVaSink(data, data);\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nstatic void goodB2GVaSink(wchar_t * data, ...)\n{\n    {\n        wchar_t dest[100] = L\"\";\n        va_list args;\n        va_start(args, data);\n        /* FIX: Specify the format disallowing a format string vulnerability */\n        _vsnwprintf(dest, 100-1, L\"%s\", args);\n        va_end(args);\n        printWLine(dest);\n    }\n}\n\nstatic void goodB2G()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    goodB2GVaSink(data, data);\n}\n\nvoid CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_01_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_01_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_01_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_01_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_01_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_01_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        char *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = strlen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(char)] = '\\0';\n            /* Eliminate CRLF */\n            replace = strchr(data, '\\r');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n            replace = strchr(data, '\\n');\n            if (replace)\n            {\n                *replace = '\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    badSink(dataList);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good function declarations */\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid goodG2BSink(list<char *> dataList);\n\nstatic void goodG2B()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    /* FIX: Append a fixed string to data (not user / external input) */\n    strcat(data, \"*.*\");\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    goodG2BSink(dataList);\n}\n\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_73; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_73; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__char_scanf_10_bad()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FLAW: Do not check the return value */\n            scanf(\"%99s\\0\", data);\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good1() uses if(globalFalse) instead of if(globalTrue) */\nstatic void good1()\n{\n    if(globalFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}\n\n/* good2() reverses the bodies in the if statement */\nstatic void good2()\n{\n    if(globalTrue)\n    {\n        {\n            /* By initializing dataBuffer, we ensure this will not be the\n             * CWE 690 (Unchecked Return Value To NULL Pointer) flaw for fgets() and other variants */\n            char dataBuffer[100] = \"\";\n            char * data = dataBuffer;\n            /* FIX: check the return value */\n            if (scanf(\"%99s\\0\", data) == EOF)\n            {\n                printLine(\"scanf failed!\");\n            }\n        }\n    }\n}\n\nvoid CWE252_Unchecked_Return_Value__char_scanf_10_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE252_Unchecked_Return_Value__char_scanf_10_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE252_Unchecked_Return_Value__char_scanf_10_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE252 - Unchecked Return Value"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE252_Unchecked_Return_Value__char_scanf_10_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE252_Unchecked_Return_Value__char_scanf_10_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE252_Unchecked_Return_Value__char_scanf_10_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_12_bad()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    else\n    {\n        /* FIX: Use a fixed string that does not contain a format specifier */\n        strcpy(data, \"fixedstringtest\");\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        badVaSinkB(data, data);\n    }\n    else\n    {\n        badVaSinkG(data, data);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* INCIDENTAL: CWE 561 Dead Code, the function below is never called */\nstatic void goodB2GVaSinkB(char * data, ...)\n{\n    {\n        char dest[100] = \"\";\n        va_list args;\n        va_start(args, data);\n        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n        vsnprintf(dest, 100-1, data, args);\n        va_end(args);\n        printLine(dest);\n    }\n}\n\nstatic void goodB2GVaSinkG(char * data, ...)\n{\n    {\n        char dest[100] = \"\";\n        va_list args;\n        va_start(args, data);\n        /* FIX: Specify the format disallowing a format string vulnerability */\n        vsnprintf(dest, 100-1, \"%s\", args);\n        va_end(args);\n        printLine(dest);\n    }\n}\n\n/* goodB2G() - use badsource and goodsink by changing the first \"if\" so that\n   both branches use the BadSource and the second \"if\" so that both branches\n   use the GoodSink */\nstatic void goodB2G()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    else\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        goodB2GVaSinkG(data, data);\n    }\n    else\n    {\n        goodB2GVaSinkG(data, data);\n    }\n}\n\n/* INCIDENTAL: CWE 561 Dead Code, the function below is never called */\nstatic void goodG2BVaSinkG(char * data, ...)\n{\n    {\n        char dest[100] = \"\";\n        va_list args;\n        va_start(args, data);\n        /* FIX: Specify the format disallowing a format string vulnerability */\n        vsnprintf(dest, 100-1, \"%s\", args);\n        va_end(args);\n        printLine(dest);\n    }\n}\n\nstatic void goodG2BVaSinkB(char * data, ...)\n{\n    {\n        char dest[100] = \"\";\n        va_list args;\n        va_start(args, data);\n        /* POTENTIAL FLAW: Do not specify the format allowing a possible format string vulnerability */\n        vsnprintf(dest, 100-1, data, args);\n        va_end(args);\n        printLine(dest);\n    }\n}\n\n/* goodG2B() - use goodsource and badsink by changing the first \"if\" so that\n   both branches use the GoodSource and the second \"if\" so that both branches\n   use the BadSink */\nstatic void goodG2B()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Use a fixed string that does not contain a format specifier */\n        strcpy(data, \"fixedstringtest\");\n    }\n    else\n    {\n        /* FIX: Use a fixed string that does not contain a format specifier */\n        strcpy(data, \"fixedstringtest\");\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        goodG2BVaSinkB(data, data);\n    }\n    else\n    {\n        goodG2BVaSinkB(data, data);\n    }\n}\n\nvoid CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_12_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_12_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_12_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE134 - Uncontrolled Format String"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_12_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_12_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_12_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_45_bad()\n{\n    char * data;\n    data = (char *)malloc(100*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_45_badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2BSink()\n{\n    char * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_45_goodG2BData;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        free(data);\n    }\n}\n\nstatic void goodG2B()\n{\n    char * data;\n    data = (char *)malloc(100*sizeof(char));\n    if (data == NULL) {exit(-1);}\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_45_goodG2BData = data;\n    goodG2BSink();\n}\n\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_45_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_45_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_45_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE122 - Heap Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_45_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_45_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_45_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (FILENAME_MAX-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgetws(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        /* Restore NUL terminator if fgetws fails */\n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B1() - use goodsource and badsink by changing the globalFive==5 to globalFive!=5 */\nstatic void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n#ifdef _WIN32\n        /* FIX: Use a fixed, full path and file name */\n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        /* FIX: Use a fixed, full path and file name */\n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if statement */\nstatic void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[FILENAME_MAX] = L\"\";\n    data = dataBuffer;\n    if(globalFive==5)\n    {\n#ifdef _WIN32\n        /* FIX: Use a fixed, full path and file name */\n        wcscat(data, L\"c:\\\\temp\\\\file.txt\");\n#else\n        /* FIX: Use a fixed, full path and file name */\n        wcscat(data, L\"/tmp/file.txt\");\n#endif\n    }\n    {\n        HANDLE hFile;\n        /* POTENTIAL FLAW: Possibly creating and opening a file without validating the file name or path */\n        hFile = CreateFileW(data,\n                            (GENERIC_WRITE|GENERIC_READ),\n                            0,\n                            NULL,\n                            OPEN_ALWAYS,\n                            FILE_ATTRIBUTE_NORMAL,\n                            NULL);\n        if (hFile != INVALID_HANDLE_VALUE)\n        {\n            CloseHandle(hFile);\n        }\n    }\n}\n\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE36_Absolute_Path_Traversal__wchar_t_file_w32CreateFile_14; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE36 - Absolute Path Traversal"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE36_Absolute_Path_Traversal__wchar_t_file_w32CreateFile_14; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int64_t_min_postdec_68_bad()\n{\n    int64_t data;\n    data = 0LL;\n    /* POTENTIAL FLAW: Use the minimum size of the data type */\n    data = LLONG_MIN;\n    CWE191_Integer_Underflow__int64_t_min_postdec_68_badData = data;\n    CWE191_Integer_Underflow__int64_t_min_postdec_68b_badSink();\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good function declarations */\nvoid CWE191_Integer_Underflow__int64_t_min_postdec_68b_goodG2BSink();\nvoid CWE191_Integer_Underflow__int64_t_min_postdec_68b_goodB2GSink();\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    int64_t data;\n    data = 0LL;\n    /* FIX: Use a small, non-zero value that will not cause an underflow in the sinks */\n    data = -2;\n    CWE191_Integer_Underflow__int64_t_min_postdec_68_goodG2BData = data;\n    CWE191_Integer_Underflow__int64_t_min_postdec_68b_goodG2BSink();\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nstatic void goodB2G()\n{\n    int64_t data;\n    data = 0LL;\n    /* POTENTIAL FLAW: Use the minimum size of the data type */\n    data = LLONG_MIN;\n    CWE191_Integer_Underflow__int64_t_min_postdec_68_goodB2GData = data;\n    CWE191_Integer_Underflow__int64_t_min_postdec_68b_goodB2GSink();\n}\n\nvoid CWE191_Integer_Underflow__int64_t_min_postdec_68_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE191_Integer_Underflow__int64_t_min_postdec_68_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE191_Integer_Underflow__int64_t_min_postdec_68_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE191 - Integer Underflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE191_Integer_Underflow__int64_t_min_postdec_68_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE191_Integer_Underflow__int64_t_min_postdec_68_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE191_Integer_Underflow__int64_t_min_postdec_68_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C++\nvoid bad()\n{\n    twoIntsStruct * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires delete to free the memory */\n    data = new twoIntsStruct;\n    badData = data;\n    badSink();\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2BSink()\n{\n    twoIntsStruct * data = goodG2BData;\n    /* POTENTIAL FLAW: Deallocate memory using delete [] - the source memory allocation function may\n     * require a call to delete to deallocate the memory */\n    delete [] data;\n}\n\nstatic void goodG2B()\n{\n    twoIntsStruct * data;\n    /* Initialize data*/\n    data = NULL;\n    /* FIX: Allocate memory from the heap using new [] */\n    data = new twoIntsStruct[100];\n    goodG2BData = data;\n    goodG2BSink();\n}\n\n/* goodB2G() uses the BadSource with the GoodSink */\nstatic void goodB2GSink()\n{\n    twoIntsStruct * data = goodB2GData;\n    /* FIX: Deallocate the memory using delete */\n    delete data;\n}\n\nstatic void goodB2G()\n{\n    twoIntsStruct * data;\n    /* Initialize data*/\n    data = NULL;\n    /* POTENTIAL FLAW: Allocate memory with a function that requires delete to free the memory */\n    data = new twoIntsStruct;\n    goodB2GData = data;\n    goodB2GSink();\n}\n\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE762_Mismatched_Memory_Management_Routines__new_delete_array_struct_45; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "CWE762 - Mismatched Memory Management Routines"}
{"input_text": "<vuln_detect> <lang> C++\nvoid good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n} /* close namespace */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nusing namespace CWE762_Mismatched_Memory_Management_Routines__new_delete_array_struct_45; /* so that we can use good and bad easily */\n\nint main(int argc, char * argv[])\n{", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_07_bad()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(staticFive==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B1() - use goodsource and badsink by changing the staticFive==5 to staticFive!=5 */\nstatic void goodG2B1()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if statement */\nstatic void goodG2B2()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(staticFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_07_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_07_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_07_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE121 - Stack Based Buffer Overflow"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_07_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_07_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_07_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_listen_socket_execlp_06_bad()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            char *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = strlen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(char)] = '\\0';\n                /* Eliminate CRLF */\n                replace = strchr(data, '\\r');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n                replace = strchr(data, '\\n');\n                if (replace)\n                {\n                    *replace = '\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    /* execlp - searches for the location of the command among\n     * the directories specified by the PATH environment variable */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B1() - use goodsource and badsink by changing the STATIC_CONST_FIVE==5 to STATIC_CONST_FIVE!=5 */\nstatic void goodG2B1()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Append a fixed string to data (not user / external input) */\n        strcat(data, \"*.*\");\n    }\n    /* execlp - searches for the location of the command among\n     * the directories specified by the PATH environment variable */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if statement */\nstatic void goodG2B2()\n{\n    char * data;\n    char dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Append a fixed string to data (not user / external input) */\n        strcat(data, \"*.*\");\n    }\n    /* execlp - searches for the location of the command among\n     * the directories specified by the PATH environment variable */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid CWE78_OS_Command_Injection__char_listen_socket_execlp_06_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__char_listen_socket_execlp_06_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__char_listen_socket_execlp_06_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__char_listen_socket_execlp_06_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__char_listen_socket_execlp_06_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__char_listen_socket_execlp_06_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_18_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET connectSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a connect socket */\n            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (connectSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n            service.sin_port = htons(TCP_PORT);\n            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed, make sure to recv one\n             * less char than is in the recv_buf in order to append a terminator */\n            /* Abort on error or the connection was closed */\n            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (connectSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(connectSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* wspawnl - specify the path where the command is located */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() - use goodsource and badsink by reversing the blocks on the goto statement */\nstatic void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FIX: Append a fixed string to data (not user / external input) */\n    wcscat(data, L\"*.*\");\n    /* wspawnl - specify the path where the command is located */\n    /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);\n}\n\nvoid CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_18_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_18_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_18_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_18_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_18_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_18_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_18_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() - use goodsource and badsink by reversing the blocks on the goto statement */\nstatic void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FIX: Append a fixed string to data (not user / external input) */\n    wcscat(data, L\"*.*\");\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_18_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_18_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_18_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE78 - OS Command Injection"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_18_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_18_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_18_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__struct_malloc_34_bad()\n{\n    twoIntsStruct * data;\n    CWE690_NULL_Deref_From_Return__struct_malloc_34_unionType myUnion;\n    data = NULL; /* Initialize data */\n    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */\n    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));\n    myUnion.unionFirst = data;\n    {\n        twoIntsStruct * data = myUnion.unionSecond;\n        /* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */\n        data[0].intOne = 1;\n        data[0].intTwo = 1;\n        printStructLine(&data[0]);\n        free(data);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodB2G() uses the BadSource with the GoodSink */\nstatic void goodB2G()\n{\n    twoIntsStruct * data;\n    CWE690_NULL_Deref_From_Return__struct_malloc_34_unionType myUnion;\n    data = NULL; /* Initialize data */\n    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */\n    data = (twoIntsStruct *)malloc(1*sizeof(twoIntsStruct));\n    myUnion.unionFirst = data;\n    {\n        twoIntsStruct * data = myUnion.unionSecond;\n        /* FIX: Check to see if the memory allocation function was successful before initializing the memory buffer */\n        if (data != NULL)\n        {\n            data[0].intOne = 1;\n            data[0].intTwo = 1;\n            printStructLine(&data[0]);\n            free(data);\n        }\n    }\n}\n\nvoid CWE690_NULL_Deref_From_Return__struct_malloc_34_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE690_NULL_Deref_From_Return__struct_malloc_34_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE690_NULL_Deref_From_Return__struct_malloc_34_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "CWE690 - Unchecked Return Value To NULL Pointer"}
{"input_text": "<vuln_detect> <lang> C\nvoid CWE690_NULL_Deref_From_Return__struct_malloc_34_good()\n{\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE690_NULL_Deref_From_Return__struct_malloc_34_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE690_NULL_Deref_From_Return__struct_malloc_34_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif", "target_text": "SAFE - No vulnerability detected"}
